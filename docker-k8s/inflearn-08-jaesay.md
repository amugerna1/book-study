# 볼륨

쿠버네티스는 다양한 유형의 볼륨을 지원한다. 파드는 여러 볼륨 유형을 동시에 사용할 수 있다. 임시 볼륨 유형은 파드의 수명을 갖지만, 퍼시스턴트 볼륨은 파드의 수명을 넘어 존재한다. 파드가 더 이상 존재하지 않으면, 쿠버네티스는 임시(ephemeral) 볼륨을 삭제하지만, 퍼시스턴트(persistent) 볼륨은 삭제하지 않는다. 볼륨의 종류와 상관없이, 파드 내의 컨테이너가 재시작되어도 데이터는 보존된다.

기본적으로 볼륨은 디렉터리이며, 일부 데이터가 있을 수 있으며, 파드 내 컨테이너에서 접근할 수 있다. 디렉터리의 생성 방식, 이를 지원하는 매체와 내용은 사용된 특정 볼륨의 유형에 따라 결정된다.

## 볼륨 유형

### emptyDir

하나의 포드 안에서 멀티 컨테이너 간 데이터를 공유하고자 할 때 사용한다.

컨테이너와 같이 사라진다.

### hostPath

호스트 노드에 있는 디렉토리를 포드에 마운트시키는 것과 같이 호스트 노드와 파드 사이에 파일시스템을 공유한다.  

파드가 배치되는 노드는 스케쥴링에 따라 달라질 수 있기 때문에 데이터를 유지하기 위해서 사용하지 않고 노드에 있는 데이터를 포드에 제공하고 싶을 때 주로 사용한다.

따라서 노드의 리소스/로그를 확인한다던지 모니터링 용도로 많이 쓰인다. 예를 들어 GCP에서 쿠버네티스 클러스터를 만들면 노드마다 노드 및 컨테이너들의 로그를 수집하기 위해 데몬셋으로 fluentbit이 떠있다.

> kubectl get pod fluentd-pod-name -n fluentbit-gke-57rmg -n kube-system -o yaml
  ```
  volumes:
  - hostPath:
      path: /var/run/google-fluentbit/pos-files
      type: ""
    name: varrun
  - hostPath:
      path: /var/log # 노드 로그
      type: ""
    name: varlog
  - hostPath:
      path: /var/lib/kubelet/pods
      type: ""
    name: varlibkubeletpods
  - hostPath:
      path: /var/lib/docker/containers # 컨테이너 로그
      type: ""
    name: varlibdockercontainers
  ```
  ### ****gcePersistentDisk (deprecated)****

클라우드 종속적 네트워크 볼륨

`gcePersistentDisk` 볼륨은 구글 컴퓨트 엔진(GCE) 영구 디스크(PD)를 파드에 마운트한다. 파드를 제거할 때 지워지는 `emptyDir` 와는 다르게, PD의 내용은 유지되고, 볼륨은 마운트 해제만 된다. 이는 PD에 데이터를 미리 채울 수 있으며, 파드 간에 데이터를 공유할 수 있다는 것을 의미한다. 구글 컴퓨트 엔진(GCE) 영구 디스크(PD)는 한개 파드와 마운트할 수 있다.

`gcePersistentDisk` 를 사용할 때 몇 가지 제한이 있다.

- 파드가 실행 중인 노드는 GCE VM이어야 함
- 이러한 VM은 영구 디스크와 동일한 GCE 프로젝트와 영역(zone)에 있어야 함

### nfs

`nfs` 볼륨을 사용하면 기존 NFS (네트워크 파일 시스템) 볼륨을 파드에 마운트 할수 있다. 파드를 제거할 때 지워지는 `emptyDir` 와는 다르게 `nfs` 볼륨의 내용은 유지되고, 볼륨은 그저 마운트 해제만 된다. 이 의미는 NFS 볼륨에 데이터를 미리 채울 수 있으며, 파드 간에 데이터를 공유할 수 있다는 뜻이다. NFS는 여러 작성자가 동시에 마운트할 수 있다.

### pv와 pvc

스토리지 관리는 컴퓨트 인스턴스 관리와는 별개의 문제다. 퍼시스턴트볼륨 서브시스템은 사용자 및 관리자에게 스토리지 사용 방법에서부터 스토리지가 제공되는 방법에 대한 세부 사항을 추상화하는 API를 제공한다. 이를 위해 퍼시스턴트볼륨 및 퍼시스턴트볼륨클레임이라는 두 가지 새로운 API 리소스를 소개한다.

*퍼시스턴트볼륨* (PV)은 관리자가 프로비저닝하거나 [스토리지 클래스](https://kubernetes.io/ko/docs/concepts/storage/storage-classes/)를 사용하여 동적으로 프로비저닝한 클러스터의 스토리지이다. 노드가 클러스터 리소스인 것처럼 PV는 클러스터 리소스이다. PV는 Volumes와 같은 볼륨 플러그인이지만, PV를 사용하는 개별 파드와는 별개의 라이프사이클을 가진다. 이 API 오브젝트는 NFS, iSCSI 또는 클라우드 공급자별 스토리지 시스템 등 스토리지 구현에 대한 세부 정보를 담아낸다.

*퍼시스턴트볼륨클레임* (PVC)은 사용자의 스토리지에 대한 요청이다. 파드와 비슷하다. 파드는 노드 리소스를 사용하고 PVC는 PV 리소스를 사용한다. 파드는 특정 수준의 리소스(CPU 및 메모리)를 요청할 수 있다. 클레임은 특정 크기 및 접근 모드를 요청할 수 있다.

인프라 세부 사항을 알지 못해도 클러스터의 스토리지를 사용할 수 있도록 제공해주는 리소스

- PVC: 개발자, PV 및 Storage는 관리자가 관리
- 덕분에 애플리케이션을 배포하는 개발자가 스토리지 기술의 종류를 몰라도 상관없다.

디스크를 할당 받지못하면 파드는 시작을 못한다.

pv 는 네임스페이스가 있지만 pvc는 네임스페이스가 없다.

파드는 claimName을 통해 pvc를 찾아 바인딩하고 pvc는 적절한 크기(storage)와 엑세스(accessModes) 가능한 PV를 찾고 바인딩한다.

Pod, PVC, PV는 바운드되어 있기 때문에 순서대로 지워야 한다.

### pv 동적프로비저닝

관리자가 StorageClass만 만들어놓으면 개발자가 PVC를 요청할때마다 PV를 만들필요가 없어진다. PVC에 storageClassName을 지정해주면 해당 클래스가 동적으로 PV를 만들고 GCE Storage 를 자동으로 만들어서 붙여준다.

가상의 디스크를 제공할 수 있는 플랫폼이 있어야 하는 제한사항이 있다. (e.g. GCP, Openstack Vsphere 등)

storageClassName를 비워두면 stardard로 디폴트로 자동으로 잡혀서 만들어진다.

pvc에 의해 pv가 만들어졌기때문에 pvc를 삭제하면 정책에 따라 pv와 storage가 관리된다.

## StatefulSet

스테이트풀셋은 애플리케이션의 스테이트풀을 관리하는데 사용하는 워크로드 API 오브젝트이다.

파드 집합의 디플로이먼트와 스케일링을 관리하며, 파드들의 *순서 및 고유성을 보장한다* .

디플로이먼트와 유사하게, 스테이트풀셋은 동일한 컨테이너 스펙을 기반으로 둔 파드들을 관리한다. 디플로이먼트와는 다르게, 스테이트풀셋은 각 파드의 독자성을 유지한다. 이 파드들은 동일한 스팩으로 생성되었지만, 서로 교체는 불가능하다. 다시 말해, 각각은 재스케줄링 간에도 지속적으로 유지되는 식별자를 가진다.

PVC를 포드와 함께 만든다.  복제 수행 시 템플릿이 자동으로 여러개 만들어지면서 PVC도 팟당 하나씩 물리게 된다.

스테이트풀셋을 삭제하더라고 PVC, PV, Storage는 남아 재생성시 같은 PVC, PV, Storage 바인딩된다.

다수의 포드를 만들게 되면 랜덤하게 이름이 만들어지는게 아니라 번호가 부여된다.

- 배포순서: 순차(0, 1, 2, …, n-1)
- 종료, 업데이트 순서: 역순(n-1, n-2, …, 0)

ClusterIP가 없는 서비스가 만들어지고 재생성 시에도 동일한 이름이 만들어지기 떄문에 각각의 파드에 도메인네임서비스를 통해서 접근할 수 있다.

## headless service

파드에 헤드리스 서비스를 연결하게 되면 쿠버네티스 클러스터 DNS(cluster.local)에 파드의 이름과 서비스의 이름이 붙여져서 도메인이름으로 등록되기 떄문에 파드는 특정파드에 접근하기 위해서 IP 주소는 필요가 없고 해당 도메인이름으로 접근할 수 있게 된다.

스테이트풀셋이 아니더라도 파드의 hostname과 subdomain을 지정하면 된다.
