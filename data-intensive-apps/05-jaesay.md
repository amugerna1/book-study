# 5장. 복제

복제란 네트워크로 연결된 여러 장비에 동일한 데이터의 복사본을 유지한다는 의미다.

데이터 복제가 필요한 이유

- 지리적으로 사용자와 가깝게 데이터를 유지해 지연 시간을 줄인다.
- 시스템의 일부에 장애가 발생해도 지속적으로 동작할 수 있게 해 가용성을 높인다.
- 읽기 질의를 제공하는 장비의 수를 확장해 읽기 처리량을 늘린다.

대표적인 복제를 위한 알고리즘

- 단일 리더(single-leader) 복제
- 다중 리더(multi-leader) 복제
- 리더 없는(leaderless) 복제

복제에 고려해야 할 트레이드오프

대개 데이터베이스 설정 옵션이다.

- 동기식 복제와 비동기식 복제 중 어떤 것을 사용할지
- 잘못된 복제본을 어떻게 처리할지

최종 일관성

- 쓰기 읽기(read-your-writes) 보장
- 단조 읽기(monotonic read) 보장

# 리더와 팔로워

## 리더 기반 복제(leader-based replication)

단일 디더 복제를 말하는 것 같다…

모든 복제본에 쓰기를 처리하는 가장 일반적인 방법이다.

복제 서버 중 하는를 리더(leader)로 지정한다. 다른 복제 서버는 팔로워(follower)라고 한다. 

여러 관계형 데이터베이스, 일부 비관계형데이터 베이스, 분산 메시지 브로커에서 사용된다.

쓰기

1. 클라이언트가 데이터베이스에 쓰기를 할 때 요청을 리더에게 보낸다.
2. 리더는 먼저 로컬 저장소에 새로운 데이터를 기록한다.
3. 리더가 로컬저장소에 새로운 데이터를 기록할 때마다 데이터 변경을 복제 로그(replication log)나 변경 스트림(change stream)의 일부로 팔로워에게 전송한다.
4. 각 팔로워가 리더로 부터 로그를 받으면 리더가 처리한 것과 동일한 순서로 모든 쓰기를 적용해 그에 맞게 데이터베이스의 로컬 복사복을 갱신한다.

읽기

클라이언트가 데이터베이스로부터 읽기를 할 때는 리더 또는 임의 팔로워에게 질의할 수 있다. 

## 동기식 대 비동기식 복제

관계형 데이터베이스에서는 보통 설정 가능한 옵션이다.

![그림 5-2](https://user-images.githubusercontent.com/19777164/191979199-2380f7dc-6bfd-463d-a9af-c10765143c81.png)


### 동기식 복제

리더는 팔로워1이 쓰기를 수신했는지 확해줄 떄까지 기다린다. 확인이 끝나면 사용자에게 성공을 보고하고 다른 클라이언트에게 해당 쓰기를 보여준다.

동기식 복제의 장점은 팔로워가 리더와 일관성 있게 최신 데이터 복사본을 가지는 것을 보장한다.

단점은 동기 팔로워가 응답하지 않는다면 쓰기를 차단(block)하고 동기 복제서버가 다시 사용할 수 있을 때까지 기다려야 한다. 임의 한노드의 장애는 전체 시스템을 멈추게 한다.

### 반동기식 복제

모든 팔로워가 동기식이라면 임의 한노드의 장애는 전체 시스템을 멈추기 때문에 모든 팔로워가 동기식인 상황은 비현실적이다. 

팔로워 하나는 동기식으로 하고 그 밖에는 비동기식으로 하여 적어도 두 노드(리더 + 팔로우 1개)에 데이터의 최신복사본이 있는 것을 보장한다.

### 비동기식 복제

리더는 메시지를 전송하지만 팔로워의 응답을 기다리지 않는다.

보통 리더 기반 복제는 완전히 비동기식으로 구성한다.

리더가 잘못되고 복구할 수 없으면 팔로워에 아직 복제되지 않은 모든 쓰기는 유실된다. 하지만 완전 비동기식 설정은 모든 팔로워가 잘못되더라도 리더가 쓰기처리를 계속 할 수 있다.
## 새로운 팔로워 설정

때때로 복제 서버 수를 늘리거나 장애 노드의 대체를 위해 새로운 팔로워를 설정해야 한다.

팔로워를 설정하는 실제 과정은 데이터베이스에 따라 크게 다르다. 일부 시스템은 설정이 완전 자동화인 반면 운영자가 수동으로 수행해야 하는 약간 애매한 여러 단계의 워크플로가 있는 경우도 있다.

새로운 팔로워가 리더의 복제본을 정확히 가지도록 중단없이 수행할 수 있다.

1. 데이터베이스 스냅숏을 일정 시점에 가져온다.
2. 스냅숏을 새로운 팔로워 노드에 복사한다.
3. 팔로워는 리더에 연결해 스냅숏 이후 발생한 모든 데이터 변경을 요청한다.
4. 팔로워가 스냅숏 이후 데이터 변경의 미처리분(backlog)을 따라잡으면 리더에 발생하는 데이터 변화를 이어 처리할 수 있다.

## 노드 중단 처리

비공유 아키텍처에서 데이터베이스 소프트웨어를 수행하는 각 장비나 가상 장비를 노드라고 부른다.

### 팔로워 장애: 따라잡기 복구

매우 쉽게 복구 가능하다. 각 팔로워는 리더로부터 수신한 데이터 변경 로그를 로컬디스크에 보관한다.

1. 보관된 로그에서 결함이 발생하기 전 마지막 트랜잭션을 알아 낸다.
2. 그러면 팔로워는 리더에 연결해 끊어진 동안 발생한 데이터 변경을 모두 요청할 수 있다.
3. 팔로워가 따라잡으면 이전과 같이 데이터 변경의 스트림을 계속 받을 수 있다.

### 리더 장애: 장애 복구

리더 장애를 처리하는 일은 까다롭다.

1. 리더가 장애인지 판단한다. 무엇이 잘못되었는지 알 수 없기 때문에 시스템은 단순히 타임 아웃을 사용한다.
2. 선출 과정이나 제어노드에 의해 새로운 리더를 선출한다.
3. 새로운 리더 사용을 위해 시스템을 재설정한다. 이전 리더가 돌아오면 이전 리더가 팔로워가 되고 새로운 리더를 인식할 수 있도록 해야 한다.

하지만 장애 복구 과정은 잘못될 수 있는 것 투성이다.

- 비동기식 복제를 사용 시 새로운 리더는 이전 리더가 장애가 나고 새로운 리더 선출 사이의 쓰기를 수신하지 못할 수 있다. 가장 일반적인 해결책은 해당 쓰기를 폐기 처분하는 것이다.
- 쓰기 폐기 시 데이터베이스 외부의 다른 저장소 시스템이 데이터베이스 내용에 맞춰 조종돼야 한다면 특히 위험하다.
- 특정 결함 시나리오에서 두 노드가 모두 자신이라고 믿을 수 있다. 이런 상황을 스플릿 브레인이라고 한다. 해당 경우 데이터 유실이나 오염이 발생할 수 있다.
- 적절한 타임아웃을 설정하기 어렵다.

이 문제에 대한 쉬운 해결책은 없기 떄문에 일부 운영팀은 소프트웨어가 자동 장애복구를 지원하더라도 수동으로 장애 복구를 수행하는 방식을 선호한다.

## 복제 로그 구현

리더 기반 복제는 다양한 복제방법을 사용한다.

### 구문 기반 복제

리더는 쓰기 요청(statement)를 수행 후 해당 구문을 팔로워에게 전달한다.

**문제점**

- NOW(), RAND() 등 비결정적 함수 사용 시 다른 값을 생산할 수 있다.
- 자동증가 컬럼 등 구문 실행 순서가 정확히 같은 순서로 실행되어야 한다.
- 트리거, 스토어드 프로시저, 사용자 정의 함수 등 부수효과를 가진 구문으로 인해 각 복제서버에서 다른 부수 효과가 발생할 수 있다.

비결정적 함수 호출을 고정 값을 반환하게 대체하는 등 해결책이 있지만 여러 에지케이스가 있기 떄문에 지금은 일반적으로 다른 방법을 선호한다. 하지만 간편해서 여전히 사용된다.

### 쓰기 전 로그 배송

로그 구조화 저장소 엔진이나 B 트리의 경우 모두 로그는 데이터베이스의 모든 쓰기를 포함하는 추가 전용(append-only) 바이트열이다. 팔로워가 이 로그를 처리하면 리더와 동일한 데이터 구조의 복제본이 만들어 진다.

단점은 로그가 제일 저수준의 데이터를 기술한다는 점이다. WAL은 어떤 디스크 블록에서 어떤 바이트를 변경했는지와 같은 상세정보도 포함한다. 그로 인해 리더와 팔로우 간의 버전 문제가 발생할 수 있다. 

### 논리적(로우 기반) 로그 복제

복제 로그를 저장소 엔진의 물리적 데이터 표현과 구별하기 위해 논리적 로그라고 부른다,

관계형 데이터베이스 용 논리적 로그는 대개 로우 단위로 데이터베이스 테이블에 쓰기를 기술한 레코드열이다.

리더와 팔로우 사이 하위호환성

### 트리거 기반 복제

일반적으로 오베헤드, 버그, 제한사항이 더 많이만 데이터베이스 서브셋 복제, 다른 데이터베이스로 복제, 충돌 해소 등 조금 더 유연성이 필요한 상황에 유용

오라클의 골든게이터(GoldenGate), 트리거, 스토어드 프로시저를 사용

동작 방법

1. 트리거는 사용자 정의 애플리케이션 코드를 등록할 수 있게 한다.
2. 트리거는 데이터 변경을 분리된 테이블에 로깅한다.
3. 이 테이블로부터 데이터 변경을 외부 프로세스가 읽는다.
4. 외부 프로세스는 필요한 애플리케이션 로직을 적용해 다른 시스템으로 데이터 변경을 복제한다.

## 복제지연 (Replication Lag)

리더에서 일어난 쓰기와 팔로워에서 반영 사이에 지연

애플리케이션이 비동기 팔로워에서 데이터를 읽을 때 팔로워가 뒤처진다면 지난 정보를 볼 수도 있다.

read-scaling 아키텍처에서는 실제로는 비동기만 가능

팔로워는 결국 리더를 따라잡는 것을 최종적 일관성(eventual consistency)이라고 한다.

### 복제 지연이 있을 때 발생할 수 있는 세가지 사례 및 해결 방법

**자신이 쓴 내용 읽기 (Reading Your Own Writes)**

쓰기 후 읽기 읽관성(read-after-write consistency)이 필요할 때 사용한다.

사용자가 페이지를 재로딩했을 떄 항상 자신이 제출한 모든 갱신을 볼 수 있음을 보장하며 다른 사용자에 대해서는 보장하지 않는다.

- 사용자가 수정한 내용을 읽을 때는 리더에서 읽는다. 애플리케이션 내 대 부분 내용을 사용자가 편집한다면 read-scaling 이점을 무효화한다.
- 리더에서 읽을지 말지 결정하기 위해 ‘마지막 갱신 후 1분동안 리더에서 모든 읽기’, ‘리더보다 1분 이상 늦은 모든 팔로워에 질의 금지’ 등 기준을 적용한다.
- 클라이언트가 가장 최근 쓰기의 타임스탬프를 기억한다. 그러면 시스템은 사용자 읽기를 위한 복제 서버가 최소한 해당 타임스탬프까지 갱신을 반영하게 할 수 있다. 동일한 사용자가 여러 디바이스로 서비스를 접근할 때 또 다른 문제가 발생한다.
- 복제서버가 여러 데이터센터에 분산됐다면 복잡도가 증가한다. 리더가 제공해야하는 모든 요청은 리더가 포함된 데이터 센터로 라우팅돼야 한다.

**단조읽기 (Monotonic Reads)**

이전에 새로운 데이터를 읽은 후에는 예전 데이터를 읽지 않음을 보장한다.

각 사용자의 읽기가 항상 동일한 복제 서버에서 수행되게끔 한다.

**일관된 순서로 읽기 (Consistent Prefix Reads)**

사용자가 데이터베이스를 읽을 때 예전 상태의 일부와 새로운 상태의 일부를 함께 볼수 있다. 이는 파티셔닝된 데이터베이스에서 발생하는 특징적인 문제이다.

일련의 쓰기가 특정 순서로 발생한다면 이 쓰기를 읽는 모든 사용자는 같은 순서로 쓰여진 내용을 보게 됨을 보장한다.

한가지 해결책은 서로 인과성이 있는 쓰기가 동일한 파티션에 기록되게끔 하는 방법이다.

**복제 지연을 위한 해결책**

애플리케이션이 기본데이터베이스보다 더 강력한 보장을 제공하는 방법은 너무 복잡해서 잘못되기 쉽다.

트랜잭션은 애플리케이션이 더 단순해지기 위해 데이터베이스가 더 강력한 보장을 제공하는 방법이다.

분산(복제되고 파티셔닝된) 데이터베이스로 전환하는 과정에서 최종적 일관성이 아닌 더 높은 보장?을 하는 여러 대안매커니즘이 있다. (3부에서 소개..)
