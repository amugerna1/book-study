# 5장. 복제

복제란 네트워크로 연결된 여러 장비에 동일한 데이터의 복사본을 유지한다는 의미다.

**데이터 복제가 필요한 이유**

- 지리적으로 사용자와 가깝게 데이터를 유지해 지연 시간을 줄인다.
- 시스템의 일부에 장애가 발생해도 지속적으로 동작할 수 있게 해 가용성을 높인다.
- 읽기 질의를 제공하는 장비의 수를 확장해 읽기 처리량을 늘린다.

**대표적인 복제를 위한 알고리즘**

- 단일 리더(single-leader) 복제
- 다중 리더(multi-leader) 복제
- 리더 없는(leaderless) 복제

**복제에 고려해야 할 트레이드오프**

대개 데이터베이스 설정 옵션이다.

- 동기식 복제와 비동기식 복제 중 어떤 것을 사용할지
- 잘못된 복제본을 어떻게 처리할지

**최종 일관성**

- 쓰기 읽기(read-your-writes) 보장
- 단조 읽기(monotonic read) 보장

# 리더와 팔로워/리더 기반 복제(leader-based replication)

## 단일 리더 복제(single-leader replication)

모든 복제본에 쓰기를 처리하는 가장 일반적인 방법이다.

복제 서버 중 하나를 리더(leader)로 지정한다. 다른 복제 서버는 팔로워(follower)라고 한다. 

여러 관계형 데이터베이스, 일부 비관계형데이터 베이스, 분산 메시지 브로커에서 사용된다.

쓰기

1. 클라이언트가 데이터베이스에 쓰기를 할 때 요청을 리더에게 보낸다.
2. 리더는 먼저 로컬 저장소에 새로운 데이터를 기록한다.
3. 리더가 로컬저장소에 새로운 데이터를 기록할 때마다 데이터 변경을 복제 로그(replication log)나 변경 스트림(change stream)의 일부로 팔로워에게 전송한다.
4. 각 팔로워가 리더로 부터 로그를 받으면 리더가 처리한 것과 동일한 순서로 모든 쓰기를 적용해 그에 맞게 데이터베이스의 로컬 복사복을 갱신한다.

읽기

클라이언트가 데이터베이스로부터 읽기를 할 때는 리더 또는 임의 팔로워에게 질의할 수 있다. 

## 동기식 대 비동기식 복제

관계형 데이터베이스에서는 보통 설정 가능한 옵션이다.

![그림 5-2](https://user-images.githubusercontent.com/19777164/191979199-2380f7dc-6bfd-463d-a9af-c10765143c81.png)


### 동기식 복제

리더는 팔로워1이 쓰기를 수신했는지 확해줄 떄까지 기다린다. 확인이 끝나면 사용자에게 성공을 보고하고 다른 클라이언트에게 해당 쓰기를 보여준다.

동기식 복제의 장점은 팔로워가 리더와 일관성 있게 최신 데이터 복사본을 가지는 것을 보장한다.

단점은 동기 팔로워가 응답하지 않는다면 쓰기를 차단(block)하고 동기 복제서버가 다시 사용할 수 있을 때까지 기다려야 한다. 임의 한노드의 장애는 전체 시스템을 멈추게 한다.

### 반동기식 복제

모든 팔로워가 동기식이라면 임의 한노드의 장애는 전체 시스템을 멈추기 때문에 모든 팔로워가 동기식인 상황은 비현실적이다. 

팔로워 하나는 동기식으로 하고 그 밖에는 비동기식으로 하여 적어도 두 노드(리더 + 팔로우 1개)에 데이터의 최신복사본이 있는 것을 보장한다.

### 비동기식 복제

리더는 메시지를 전송하지만 팔로워의 응답을 기다리지 않는다.

보통 리더 기반 복제는 완전히 비동기식으로 구성한다.

리더가 잘못되고 복구할 수 없으면 팔로워에 아직 복제되지 않은 모든 쓰기는 유실된다. 하지만 완전 비동기식 설정은 모든 팔로워가 잘못되더라도 리더가 쓰기처리를 계속 할 수 있다.
## 새로운 팔로워 설정

때때로 복제 서버 수를 늘리거나 장애 노드의 대체를 위해 새로운 팔로워를 설정해야 한다.

팔로워를 설정하는 실제 과정은 데이터베이스에 따라 크게 다르다. 일부 시스템은 설정이 완전 자동화인 반면 운영자가 수동으로 수행해야 하는 약간 애매한 여러 단계의 워크플로가 있는 경우도 있다.

새로운 팔로워가 리더의 복제본을 정확히 가지도록 중단없이 수행할 수 있다.

1. 데이터베이스 스냅숏을 일정 시점에 가져온다.
2. 스냅숏을 새로운 팔로워 노드에 복사한다.
3. 팔로워는 리더에 연결해 스냅숏 이후 발생한 모든 데이터 변경을 요청한다.
4. 팔로워가 스냅숏 이후 데이터 변경의 미처리분(backlog)을 따라잡으면 리더에 발생하는 데이터 변화를 이어 처리할 수 있다.

## 노드 중단 처리

비공유 아키텍처에서 데이터베이스 소프트웨어를 수행하는 각 장비나 가상 장비를 노드라고 부른다.

### 팔로워 장애: 따라잡기 복구

매우 쉽게 복구 가능하다. 각 팔로워는 리더로부터 수신한 데이터 변경 로그를 로컬디스크에 보관한다.

1. 보관된 로그에서 결함이 발생하기 전 마지막 트랜잭션을 알아 낸다.
2. 그러면 팔로워는 리더에 연결해 끊어진 동안 발생한 데이터 변경을 모두 요청할 수 있다.
3. 팔로워가 따라잡으면 이전과 같이 데이터 변경의 스트림을 계속 받을 수 있다.

### 리더 장애: 장애 복구

리더 장애를 처리하는 일은 까다롭다.

1. 리더가 장애인지 판단한다. 무엇이 잘못되었는지 알 수 없기 때문에 시스템은 단순히 타임 아웃을 사용한다.
2. 선출 과정이나 제어노드에 의해 새로운 리더를 선출한다.
3. 새로운 리더 사용을 위해 시스템을 재설정한다. 이전 리더가 돌아오면 이전 리더가 팔로워가 되고 새로운 리더를 인식할 수 있도록 해야 한다.

하지만 장애 복구 과정은 잘못될 수 있는 것 투성이다.

- 비동기식 복제를 사용 시 새로운 리더는 이전 리더가 장애가 나고 새로운 리더 선출 사이의 쓰기를 수신하지 못할 수 있다. 가장 일반적인 해결책은 해당 쓰기를 폐기 처분하는 것이다.
- 쓰기 폐기 시 데이터베이스 외부의 다른 저장소 시스템이 데이터베이스 내용에 맞춰 조종돼야 한다면 특히 위험하다.
- 특정 결함 시나리오에서 두 노드가 모두 자신이라고 믿을 수 있다. 이런 상황을 스플릿 브레인이라고 한다. 해당 경우 데이터 유실이나 오염이 발생할 수 있다.
- 적절한 타임아웃을 설정하기 어렵다.

이 문제에 대한 쉬운 해결책은 없기 떄문에 일부 운영팀은 소프트웨어가 자동 장애복구를 지원하더라도 수동으로 장애 복구를 수행하는 방식을 선호한다.

## 복제 로그 구현

리더 기반 복제는 다양한 복제방법을 사용한다.

### 구문 기반 복제

리더는 쓰기 요청(statement)를 수행 후 해당 구문을 팔로워에게 전달한다.

**문제점**

- NOW(), RAND() 등 비결정적 함수 사용 시 다른 값을 생산할 수 있다.
- 자동증가 컬럼 등 구문 실행 순서가 정확히 같은 순서로 실행되어야 한다.
- 트리거, 스토어드 프로시저, 사용자 정의 함수 등 부수효과를 가진 구문으로 인해 각 복제서버에서 다른 부수 효과가 발생할 수 있다.

비결정적 함수 호출을 고정 값을 반환하게 대체하는 등 해결책이 있지만 여러 에지케이스가 있기 떄문에 지금은 일반적으로 다른 방법을 선호한다. 하지만 간편해서 여전히 사용된다.

### 쓰기 전 로그 배송

로그 구조화 저장소 엔진이나 B 트리의 경우 모두 로그는 데이터베이스의 모든 쓰기를 포함하는 추가 전용(append-only) 바이트열이다. 팔로워가 이 로그를 처리하면 리더와 동일한 데이터 구조의 복제본이 만들어 진다.

단점은 로그가 제일 저수준의 데이터를 기술한다는 점이다. WAL은 어떤 디스크 블록에서 어떤 바이트를 변경했는지와 같은 상세정보도 포함한다. 그로 인해 리더와 팔로우 간의 버전 문제가 발생할 수 있다. 

### 논리적(로우 기반) 로그 복제

복제 로그를 저장소 엔진의 물리적 데이터 표현과 구별하기 위해 논리적 로그라고 부른다,

관계형 데이터베이스 용 논리적 로그는 대개 로우 단위로 데이터베이스 테이블에 쓰기를 기술한 레코드열이다.

리더와 팔로우 사이 하위호환성

### 트리거 기반 복제

일반적으로 오베헤드, 버그, 제한사항이 더 많이만 데이터베이스 서브셋 복제, 다른 데이터베이스로 복제, 충돌 해소 등 조금 더 유연성이 필요한 상황에 유용

오라클의 골든게이터(GoldenGate), 트리거, 스토어드 프로시저를 사용

동작 방법

1. 트리거는 사용자 정의 애플리케이션 코드를 등록할 수 있게 한다.
2. 트리거는 데이터 변경을 분리된 테이블에 로깅한다.
3. 이 테이블로부터 데이터 변경을 외부 프로세스가 읽는다.
4. 외부 프로세스는 필요한 애플리케이션 로직을 적용해 다른 시스템으로 데이터 변경을 복제한다.

## 복제지연 (Replication Lag)

리더에서 일어난 쓰기와 팔로워에서 반영 사이에 지연

애플리케이션이 비동기 팔로워에서 데이터를 읽을 때 팔로워가 뒤처진다면 지난 정보를 볼 수도 있다.

read-scaling 아키텍처에서는 실제로는 비동기만 가능

팔로워는 결국 리더를 따라잡는 것을 최종적 일관성(eventual consistency)이라고 한다.

### 복제 지연이 있을 때 발생할 수 있는 세가지 사례 및 해결 방법

**자신이 쓴 내용 읽기 (Reading Your Own Writes)**

쓰기 후 읽기 읽관성(read-after-write consistency)이 필요할 때 사용한다.

사용자가 페이지를 재로딩했을 떄 항상 자신이 제출한 모든 갱신을 볼 수 있음을 보장하며 다른 사용자에 대해서는 보장하지 않는다.

- 사용자가 수정한 내용을 읽을 때는 리더에서 읽는다. 애플리케이션 내 대 부분 내용을 사용자가 편집한다면 read-scaling 이점을 무효화한다.
- 리더에서 읽을지 말지 결정하기 위해 ‘마지막 갱신 후 1분동안 리더에서 모든 읽기’, ‘리더보다 1분 이상 늦은 모든 팔로워에 질의 금지’ 등 기준을 적용한다.
- 클라이언트가 가장 최근 쓰기의 타임스탬프를 기억한다. 그러면 시스템은 사용자 읽기를 위한 복제 서버가 최소한 해당 타임스탬프까지 갱신을 반영하게 할 수 있다. 동일한 사용자가 여러 디바이스로 서비스를 접근할 때 또 다른 문제가 발생한다.
- 복제서버가 여러 데이터센터에 분산됐다면 복잡도가 증가한다. 리더가 제공해야하는 모든 요청은 리더가 포함된 데이터 센터로 라우팅돼야 한다.

**단조읽기 (Monotonic Reads)**

이전에 새로운 데이터를 읽은 후에는 예전 데이터를 읽지 않음을 보장한다.

각 사용자의 읽기가 항상 동일한 복제 서버에서 수행되게끔 한다.

**일관된 순서로 읽기 (Consistent Prefix Reads)**

사용자가 데이터베이스를 읽을 때 예전 상태의 일부와 새로운 상태의 일부를 함께 볼수 있다. 이는 파티셔닝된 데이터베이스에서 발생하는 특징적인 문제이다.

일련의 쓰기가 특정 순서로 발생한다면 이 쓰기를 읽는 모든 사용자는 같은 순서로 쓰여진 내용을 보게 됨을 보장한다.

한가지 해결책은 서로 인과성이 있는 쓰기가 동일한 파티션에 기록되게끔 하는 방법이다.

**복제 지연을 위한 해결책**

애플리케이션이 기본데이터베이스보다 더 강력한 보장을 제공하는 방법은 너무 복잡해서 잘못되기 쉽다.

트랜잭션은 애플리케이션이 더 단순해지기 위해 데이터베이스가 더 강력한 보장을 제공하는 방법이다.

분산(복제되고 파티셔닝된) 데이터베이스로 전환하는 과정에서 최종적 일관성이 아닌 더 높은 보장?을 하는 여러 대안매커니즘이 있다. (3부에서 소개..)

# 다중 복제 리더 (**Multi-Leader Replication)**

쓰기를 허용하는 노드를 하나 이상 둔다.

단일 데이터센터 내에서는 다중 복제 리더로 인한 복잡도에 비해 이점이 크지 않기 때문에 합리적이지 않다.

쓰기 충돌 문제 등 많은 어려움이 있다.

## 고려해볼만한 사용사례

다중 데이터센터 운영 시 성능(latency), 데이터센터 중단 내성, 네트워크 문제 내성에 이점을 누리고 싶을떄 사용할 수 있다.

인터넷 연결이 끊어진 동안 애플리케이션이 계속 동작해야 하는 경우 로컬데이터베이스를 리더로 사용하고 복제서버 간 다중 리더 복제를 비동기 방식으로 수행할 수 있다.

실시간 협업편집 애플리케이션의 경우 변경 내용을 즉시 로컬 복제 서버에 적용하고 나서 동일한 문서를 편집하는 다른 사용자와 서버에 비동기 방식으로 복제한다. (오프라인 편집과 유사)

## 쓰기 충돌 다루기 (**Handling Write Conflicts**)

다중 리더 복제에서 제일 큰 문제는 쓰기 충돌이 발생한다는 점이다. 이는 충돌 해소가 필요하다는 의미이다.

![그림 5-7](https://user-images.githubusercontent.com/19777164/192092043-1cb82c63-cea4-41d1-8c11-288cdfc346d1.png)

### 동기 대 비동기 충돌 감지 (**Synchronous versus asynchronous conflict detection**)

이론적으로 모든 충돌감지는 동기식으로 만들 수 있지만 그럴 경우 다중 리더복제의 주요 장점을 잃는다.

**충돌 회피(Conflict avoidance)**

특정 레코드의 모든 쓰기가 동일한 리더를 거치도록 애플리케이션이 보장한다면 충돌은 발생하지 않는다. 많은 다중 리더 복제 구현 사례에서 충돌을 잘 처리하지 못하기 떄문에 충돌을 피하는 것이 자주 권장되는 방법이다.

**일관된 상태 수렴(Converging toward a consistent state)**

모든 복제 계획은 모든 복제 서버가 최종적으로 동일하다는 사실을 보장해야 한다. 따라서 데이터베이스는 수렴(convergent) 방식으로 충돌을 해소해야 한다. 

수렴 충돌 해소를 달성하는 다양한 방법이 있다.

- 각 쓰기에 고유 ID를 부여하고 가장 높은 ID를 가진 쓰기를 고른다. 데이터 유실 가능성이 있다.
- 각 복제 서버에 고유 ID를 부여하고 높은 숫자를 가진 복제 서버에서의 쓰기를 우선적으로 적용한다. 데이터 유실 가능성이 있다.
- 어떻게든 값을 병합한다. 예를 들어 사전 순으로 정렬한 후 연결한다.
- 충돌을 기록하고 나중에 사용자에게 메시지를 보여주는 등 애플리케이션 코드를 작성한다.

**사용자 정의 충돌 해소 로직(Custom conflict resolution logic)**

충돌을 해소하는 가장 적합한 방법은 애플리케이션에 따라 다르다. 따라서 대부분의 다중 리더 복제 도구는 애플리케이션 코드를 사용해 충돌 해소 로직을 작성한다.

**자동 충돌 해소(Automatic Conflict Resolution)**

자동 충돌 해소는 애플리케이션이 다루는 다중 리더 데이터 동기화를 훨씬 단순하게 만든다.

Conflict-free replicated datatypes (CRDTs), Mergeable persistent data structures, Operational transformation 등 동시에 데이터를 수정할 때 발생하는 충돌을 자동으로 해소해주는 흥미로운 연구가 있다. 아직 성숙한 단계는 아니라고 한다.

## **다중 리터 복제 토폴로지(Multi-Leader Replication Topologies)**

복제 토폴로지는 쓰기를 한 노드에서 다른 노드로 전달하는 통신 경로를 설명한다.

![그림 5-8](https://user-images.githubusercontent.com/19777164/192092081-152e2e5b-7cc1-4fbc-a638-2d65202e4215.png)

### 전체 연결(all-to-all)

가장 일반적인 방법이다.

모든 리더가 각자의 쓰기를 다른 모든 리더에게 전송한다.

인과성 문제가 발생할 수 있고 이런 이벤트를 올바르게 정렬하기 위해 버전백터(version vector) 기법을 사용할 수 있지만 많은 다중 복제 시스템에서 충돌 감지 기법은 제대로 구현되지 않았다.

![그림 5-9](https://user-images.githubusercontent.com/19777164/192092098-365f84a9-7d35-4a0e-8646-429c0643f49b.png)


단일 장애점을 피할 수 있기 떄문에 내결함성이 좋다.

### 원형 토폴로지(circular topology)

각 노드가 하나의 노드로부터 쓰기를 받고, 이 쓰기에 자신의 쓰기도 추가하여 함께 다른 한노드에 전달한다.

모든 복제노드에 도달하기 전에 여러 노드를 거쳐야 한다.

### 별모양 토폴로지(star topology)

지점된 루트노드 하나가 다른 모든 노드에 쓰기를 전달한다. 

별 모양 토폴로지는 트리로 일반화될 수 있다.

모든 복제노드에 도달하기 전에 여러 노드를 거쳐야 한다.

# 리더 없는 복제 (**Leaderless Replication**)

일부 데이터 저장소 시스템은 리더의 개념을 버리고 모든 복제 서버가 클라이언트로 부터 쓰기를 직접 받을 수 있게 허용하는 접근 방식을 사용하기도 한다.

리더없는 복제는 아마존이 내부 다이나모(Dynamo) 시스템에서 사용한 후 데이터베이스용 아키텍처로 유행했다. 이런 종류의 데이터베이스를 다이나모 스타일이라 한다.

클라이언트가 여러 복제 서버에 쓰기를 직접 전송하거나 코디네이터 노드(coordinator node)가 클라이언트를 대신해 이를 수행하기도 한다. 하지만 리더 베이스 복제와 코디네이터 노드는 달리 특정 순서로 쓰기를 수행하지 않는다.

노드 다운 시 누락된 쓰기를 따라잡기 위해 읽기 복구(Read repair)와 안티 엔트로피 처리 (Anti-entropy process) 메커니즘을 사용하지만 모든 시스템이 이 두가지를 모두 구현하는 건 아니다.

- 읽기 복구(Read repair)
    - 오래된 값이라는 사실을 알면 해당 복제 서버에 새로운 값을 다시 기록한다.
    - 이 접근 방식은 값을 자주 읽는 상황에 적합하다.
- 안티 엔트로피 처리 (Anti-entropy process)
    - 백그라운드 프로세스를 두고 복제 서버 간 데이터 차이를 지속적으로 찾아 누락된 데이터를 하나의 복제 서버에서 다른 서버로 복사한다.

다이나모 스타일 데이터베이스는 일반적으로 최종적 일관성을 허용하는 사례에 맞게 최적화됐다. 정족수를 통해 오래된 값을 읽는 확률을 조정할 수 있지만 이를 절대적으로 보장할 수는 없다.

리더 없는 복제 데이터베이스에서 복제서버의 오래됨(staleness)을 측정하고 매개변수 n, w, r에 따라 오래된 값을 읽는 비율을 예측(정량화)하는 연구가 있었지만 아직 일반적이지 않다.

## 정족수(**Quorums**)

정족수 조건이 w + r > n 이면 최신 값을 계속 반환 받을 수 있도록 확률을 높일 수는 있지만 . 하지만 w + r > n인 경우에도 오래된 값을 반환하는 에지 케이스가 있다. (정족수 일관성의 한계가 있다)

일반적으로 읽기와 쓰기는 항상 모든 n개의 복제 서버에 병렬로 전송한다.

필요한 w나 r개 노드보다 사용 가능한 노드가 적다면 쓰기나 읽기는 에러를 반환한다.

가용성을 높이기 위해 w나 r 노드 정족수를 만족하지 않는 모든 요청에 오류를 반환하지 않고 일단 쓰기를 받아들이고 값이 보통 저장되는 n개 노드에 속하지는 않지만 연결할 수 있는 노드에 기록하는 방식을 느슨한 정족수(sloppy quorums)라고 부른다. 장애 상황이 해제되면 한 노드가 다른 노드를 위해 일시적으로 수용한 모든 쓰기를 해당 “홈” 노드로 전송하는 방식을 암시된 핸드오프(hinted handoff)라 부른다.

## 동시 쓰기(Concurrent Writes)

### 최종쓰기 승리(동시 쓰기 버리기) (**Last write wins (discarding concurrent writes))**

비록 자연적인 순서가 없지만 임의로 순서를 정할 수 있다.

LWW에서는 쓰기에 타임스탬프를 붙여 가장 “최신”이라는 의미로 제일 큰 타임스탬프를 선택하고 예전 타임스탬프를 가진 쓰기는 무시한다.

LWW는 최종 수렴 달성이 목표지만 지속성을 희생한다. 동일한 키에 여러번의 동시 쓰기가 있다면 클라이언트에게 모두 성공으로 보고될지라도 쓰기 중 하나만 남고 다른 쓰기는 조용히 무시된다.

### “이전발생” 관계와 동시성(**The “happens-before” relationship and concurrency)**

![그림 5-12](https://user-images.githubusercontent.com/19777164/192131415-6047fbeb-ceef-48d4-8efb-51776ad4ca9a.png)

작업 B가 작업 A에 대해서 알거나 A에 의존적이거나 어떤 방식으로 A를 기반으로 한다면 작업 A는 작업 B의 이전발생(hanppens-before)이다. 한 작업이 다른 작업 이전에 발생했는지가 동시성의 의미를 정의하는 핵심이다. 사실 다른 작업보다 먼저 발생하지 않으면(즉 어느 작업도 다른 작업에 대해 알지 못한다면) 단순히 동시 작업이라고 말한다.

![그림 5-13](https://user-images.githubusercontent.com/19777164/192131452-2fa801f4-b80d-4eeb-aefa-4d272550567a.png)

쓰기가 이전 읽기의 버전 번호를 포함하면 쓰기가 수행되기 이전 상태를 알 수 있다. 버전 번호를 포함하지 않은 쓰기는 다른 쓰기와 동시에 수행된 것이므로 아무것도 덮어쓰지 않는다.(후속 읽기의 값 중 하나로 반환된다.) 해당 알고리즘은 동시에 쓴 값 병합 시 어떤 데이터도 자동으로 삭제되지 않음을 보장하지만 불행히도 클라이언트가 추가적으로 작업을 수행해야 한다. 시스템은 형제(동시값)를 병합할때 상품을 제거했음을 나타내기 위해 해당 버전 번호에 표시를 남겨둬야 한다. 이런 삭제 표시를 툼스톤(tombstone)이라 한다. 자동으로 병합을 수행할 수 있게 데이터 구조를 설계하려는 노력이 있다.(e.g. CRDT)

다중 복제본의 동시쓰기를 받아들이기 위해서는 키당 버전 번호뿐만 아니라 복제본당 버전 번호도 사용해야 한다. 각 복제본은 쓰기를 처리할 때 자체 버전번호를 증가시키고 각기 다른 복제본의 버전 번호도 계속 추적해야 한다. 그러한 모든 복제본의 버전 번호 모음을 버전 벡터(version vector)라고 부른다.
