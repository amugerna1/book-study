# 4장. 부호화와 발전

# 데이터 부호화 형식

프로그램은 보통 (최소한) 두 가지 형태로 표현된 데이터를 사용해 동작한다.

메모리에 객체(object), 구조체(struct), 목록(list), 배열(array), 해시 테이블(hash table), 트리(tree) 등으로 데이터가 유지 된다. 이런 데이터 구조는 CPU에서 효율적으로 접근하고 조작할 수 있게 (보통은 포인터를 이용해) 최적화된다.

데이터를 파일에 쓰거나 네트워크를 통해 전송하려면 일련의 바이트열(e.g. JSON)의 형태로 부호화해야 한다. JSON, XML, Protocol Buffers, Thrift, Avro를 비롯해서 데이터 부호화를 위한 다양한 형식이 있다.

인메모리 표현 → 바이트열 : 부호화, 직렬화, 마샬링

바이트열 → 인메모리 표현 : 복호화, 파싱, 역직렬화, 언마샬링

## 언어별 형식

자바의 serializable 등 많은 프로그래밍 언어는 인메모리 객체를 바이트열로 부호화하는 기능을 내장한다.

언어에 내장된 부호화를 사용하는 방식은 일반적으로 좋지 않다.

- 다른 언어와 통합하기 어렵다
- 데이터를 복원하려면 복호화 과정이 임의의 클래스를 인스턴스화할 수 있어야 한다 ⇒ 보안문제
- 데이터를 빠르고 쉽게 보호화하기 위해 상위, 하위 호환성의 호환성의 불편한 문제가 등한시 되곤 한다.
- 효율성(부호화나 복호화에 소요되는 CPU 시간과 부호화된 구조체 크기)도 나중에 생각하게 된다.

effective 자바 12장 참고

## JSON, XML

텍스트형식이라서 어느정도 사람이 읽을 수 있다.

JSON의 인기는 주로 웹브라우저에 내장된 자원과 XML의 비해 단순하기 때문이다.

number 부호화 애매함

이진문자열을 지원하지 않음

데이터 교환 형식으로 사용하기에 매우 좋다.

## 이진 변형 (Binary Variants)

조직 내에서만 사용하는 데이터라면 조금 더 간편하고 파싱이 빠른 형식을 선택할 수 있다. 작은 데이터셋의 경우에는 부호화 형식 선택으로 얻는 이득이 무시할 정도지만 테라바이트 정도가 되면 데이터 타입의 선택이 큰 영향을 미친다.

### 이진부호화

스키마를 지정하지 않기 떄문에 부호화된 데이터 안에 모든 객체의 필드를 포함해야 한다. 그래서 공간을 많이 절약할 수 없다.

작은 공간의 절약과 (어쩌면) 파싱속도의 향상이 사람의 가독성을 해칠 만큼 가치가 있는지 확실하지 않다.

필드가 필수인지 아닌지 나타내지 않는다.

### 스리프트와 프로토콜 버퍼

```protobuf
message SearchRequest {
  string query = 1;
  int32 page_number = 2;
  int32 result_per_page = 3;
}
```

IDL을 사용해서 스키마(필드태그, 데이터 타입 등)를 기술해야 한다.

필드 이름 대신 부호화된 데이터는 스키마에 정의된 숫자(1,2,3)과 같은 필드 태그를 포함한다.

가변 길이 정수를 사용해서 부호화한다.

optional, required를 통해 필드가 필수인지 아닌지 나타낸다. 부호화 시 차이는 없고 스키마를 통해 실행 시 확인할 수 있다.

스키마를 정의한 후 선택한 프로그래밍 언어로 스키마를 구현한 코드를 생성할 수 있다. 

[proto3 가이드](https://developers.google.com/protocol-buffers/docs/proto3)

**스키마 발전**

필드 태그는 기존의 모든 부호화된 데이터를 인식 불가능하게 만들 수 있기 떄문에 변경할 수 없다.

필드에 새로운 태그번호를 부여하는 방식으로 스키마에 새로운 필드를 추가할 수 있다.

알지 못하는 필드 태그를 읽으려는 경우 데이터타입 주석을 통해 파서가 몇바이트를 건너뛸 수 있는지 알려줄 수 있기 때문에 상위호환성을 유지하게 할 수 있다.

하위호환성을 유지할 수 있다. 각 필드가 고유한 태그 번호가 있는 동안에는 태그 번호가 계속 같은 의미를 가지고 있기 때문에 새로운 코드가 예전데이터를 항상 읽을 수 있다. 초기 배포 후에 추가되는 모든 필드는 optional로 하거나 기본값을 가져야 한다.

데이터 타입을 변경할 경우 값이 정확하지 않거나 잘릴 위험이 있다. int32를 int64로 바꿀경우 새로운 코드가 기록한 64비트 정수를 예전 코드에서 사용할 시 잘릴 수 있다. protobuf의 단일 값인 optional 필드를 repeated (다중 값인) repeated로 변경해도 문제 없다. 따라서 잘 알아보고 사용해야 한다.

### 아브로

태그 번호가 없다.

부호화된 데이터(바이트열)는 필드나 데이터타입을 식별하기 위한 정보가 없다.

정수는 가변 길이 부호화를 사용해서 부호화한다.

데이터를 읽는 코드가 데이터를 기혹한 코드와 정확히 같은 스키마를 사용하는 경우에만 이진 데이터를 올바르게 복호화 할 수 있다.

**스키마발전**

아브로의 핵심 아이디어는 쓰기 스키마와 읽기 스키마가 동일하지 않아도 되며 단지 호환 가능하면 된다는 것이다.

데이터를 복호화(읽기)할 때 아브로 라이브러리는 쓰기 스키마와 읽기 스키마를 함께 살펴본 다음 쓰기 스키마에서 읽기 스키마로 데이터를 변환해 그 차이를 해소한다.

스키마 해석에서는 이름으로 필드를 일치시키기 떄문에 데이터의 순서가 달라도 상관없다.

호환성을 유지하기 위해서는 기본값이 있는 필드만 추가하거나 삭제할 수 있다.

null 사용을 구분하기 위해 union 사용

유니온 타입에 엘리먼트를 추가하는 것은 하위 호환성은 있지만 상위 호환성은 없다.

아브로는 타입을 변환할 수 있으므로 필드의 데이터타입 변경이 가능하다.

별칭으로 유지할 수 있기 때문에 필드 이름 변경은 하위 호환성이 있지만 상위호환성은 없다.

쓰기 스키마를 공유하는 방법은 상황마다 다르게 가져갈 수 있다.

- 쓰기 시작 시 스키마 포함 (요것을 위해 객체 컨테이너 파일이라는 파일 형식)
- 레코드 시작 부분에 버전번호 포함하고 데이터베이스에는 스키마 버전 목록을 유지
- 두 프로세스가 양방향 네트워크 연결을 통해 통신할 때 연결 설정에서 스키마 버전 합의를 할 수 있다.

태그번호가 없기 때문에 프로토콜 버퍼나 스리프트에 비해  동적 생성 스카마가 훨씬 쉽다.

정적 타입 프로그래밍 언어를 위해 코드 생성을 선택적으로 제공한다.

객체컨테이너파일이 필요한 메타데이터를 모두 포함하기 떄문에 자기기술(self-describing)적이다.

## 스키마 장점

프로토콜 버퍼와 스리프트, 아브로는 스키마를 사용해 이진 부호화 형식을 기술 한다. 

스키마(IDL) 언어는 XML 스키마나 JSON 스키마보다 훨씬 간단하며 더 자세한 유효성 검사 규칙을 지원한다.

부호화된 데이터에서필드이름을 생략할 수 있기 때문에 다양한 “이진 JSON” 변형보다 크기가 훨씬 작을 수 있다.

스키마는 유용한 문서화 형식이다. (코드 generation 등도 직접하기 떔 수동 관리 X)

스키마 데이터베이스를 유지하면 스키마 변경이 적용되기 전에 상위호환성과 하위 호환성을 유지할 수 있다.

정적 타입 프로그래밍 언어 사용자에게 스키마로부터 코드 생성하는 기능은 유용하다.

요약하는 스키마 발전은 스키마리스 또는 읽기 스키마 JSON 데이터베이스가 제공하는 것과 동일한 종류의 유연성을 제공하며 데이터나 도구 지원도 더 잘 보장한다.

# Dataflow

데이터플로는 매우 추상적인 개념으로서 하나의 프로세스에서 다른 프로세스로 데이터를 전달하는 방법은 아주 많다.

## 데이터베이스를 통한 데이터플로

데이터베이스에 저장하고 읽어서 데이터를 전달한다.

미래의 저장된 데이터를 읽기 때문에 하위 호환성 필요

롤링업데이트 시 새로운버전의 코드로 기록된 데이터를 예전 버전에서 읽을 수 있기 때문에 상위 호환성 필요

대부분의 관계형 데이터베이스는 기존 데이터를 다시 기록하지 않고 널을 기본값으로 갖는 새로운 컬럼을 추가하는 간단한 스키마 변경을 허용한다. MySQL의 경우는 필요하지 않은 상황에서도 대개 전체 테이블을 다시 기록한다.

스키마 발전은 기본저장소가 여러가지 버전의 스키마로 부호화된 레코드를 포함해도 전체 데이터베이스가 단일 스키마로 부호화된 것처럼 보이게 한다.

## 서비스를 통한 데이터플로: REST와 RPC

일반적으로 클라이언트와 서버의 배치

서버가 공개한 API를 서비스라고 한다.

API는 표준화된 프로코톨과 데이터 타입(HTTP, URL, SSL/TLS, HTML 등)으로 구성된다.

웹브라우저, 모바일 디바이스, 데스크톱 컴퓨터, 더욱이 서버 자체가 다른 서비스의 클라이언트일 수 있다.

SOA 및 MSA 핵심설계 목표는 서비스를 배포와 변경에 독립적으로 만들어 애플리케이션 변경과 유지보수를 더 쉽게 할 수 있게 만드는 것이다. 다시 말해 예전 버전과 새로운 버전의 서버와 클라이언트가 동시에 실행되기를 기대한다. 따라서 서버와 클라이언트가 사용하는 데이터 부호화는 서비스 API 버전 간 호환이 가능해야 한다. 이점이 바로 이번 장의 핵심이다.

### 웹서비스

서비스와 통신하기 위한 기본 프로토콜로 HTTP를 사용할 때 이를 웹서비스라고 한다. 웹 뿐만 아니라 다양한 상황에서도 사용되기 떄문에 아마도 약간 잘못된 표현일 수 있음..애매..

**REST**

REST는 프로토콜이 아니라 HTTP의 원칙을 토대로한 설계 철학이다. REST는 간단한 데이터 타입을 강조하며 URL을 사용해 리소스를 식별하고 캐시제어, 인증, 콘텐츠 유형 협상에 HTTP 기능을 사용한다. REST 원칙에 따라 설계된 API를 RESTful이라고 한다. RESTful API는 간단한 접근 방식을 선호한다. 일반적으로 코드 생성과 자동화된 도구와 관련되지 않은 접근 방식을 말한다 스웨거로 알려진 오픈 API 같은 정의 형식을 사용해 RESTful API와 제품문서를 기술하는 데 사용할 수 있다. API 버전 관리가 반드시 어떤 방식으로 동작해야 한다는 협의는 없다. RESTful API는 URL이나 HTTP Accept 헤더에 버전번호를 사용하는 방식이 일반적이다. 특정클라이언트를 식별하는데 API 키를 사용하는 서비스는 클라이언트의 요청 API 버전을 서버에 저장한 뒤 버전 선택을 별도 관리 인터페이스를 통해 갱신할 수 있게 하는 것이 한가지 방식이다.

REST가 네트워크 프로토콜이라는 사실을 숨기려 하지 않는다.

실제 디버깅에 적합하다. 코드 생성이나 소프트웨어 설치 없이 웹브라우저나 커맨드라인 도구인 curl 사용해 간단히 요청을 보낼수 있다.

모든 주요 프로그래밍 언어와 플랫폼이 지원하고 사용가능한 다양한 도구 생태계(서버, 캐시로드밸런서, 프락시, 방화벽, 모니터링, 디버깅 도구, 테스팅 도구 등)가 있다.

이런 이유로 REST는 공개 API에 주요한 방식 처럼 보인다.

**SOAP**

SOAP는 네트워크 API 요청을 위한 XML 기반 프로토콜이다.비록 SOAP는 HTTP 상에서 가장 일반적으로 사용되지만 HTTP와 독립적이며 대부분의 HTTP 기능을 사용하지 않는다. 그 대신 다양한 기능을 추가한 광범위하고 복잡한 여러 관련 표준(WS-*라고 알려진 웹 서비스 프레임워크)을 제공한다. (책 136페이지 더 참고..WSDL…단점 등..)

### RPC

RPC 모델은 원격 네트워크 서비스 요청을 같은 프로세스 안에서 특정 프로그래밍 언어의 함수나 메서드를 호출하는 것과 동일하게 사용 가능하게 해준다. 이런 추상화를 위치 투명성(location transparency)라고 한다. 

네트워크 요청은 로컬함수호출과는 매우 달라 근본적으로 결함이 있다. 그렇다고 원격 서비스를 최대한 프로그래밍 언어 내 로컬 객체처럼 보이게끔 하는 노력 자체가 소용없다는 의미는 아니다.

많은 부호화 위에는 다양한 RPC 프레임워크가 개발되었다. gRPC는 프로토콜 버퍼를 이용한 RPC 구현이다. 

차세대 RPC 프레임워크는 원격 요청이 로컬함수 호출과 다르다는 사실을 더욱 분명히 한다.

이런 프레임워크 중 일부는 서비스 찾기(service discovery)를 제공한다. (즉 클라이언트가 특정 서비스를 찾을 수 있는 IP 주소와 포트번호를 제공)

REST 상에서 JSON과 같은 부류의 프로토콜보다 이진 부호화 형식을 사용하는 사용자 정의 RPC 프로토콜이  우수한 성능을 제공할지 모른다.

스리프트, gRPC(프로토콜 버퍼), 아브로 PRC는 각 부호화 형식의 호환성 규칙에 따라 발전할 수 있다.

## 메시지 전달 플로

클라이언트 요청(메시지)을 낮은 지연 시간으로 다른 프로세스에 전달한다는 점에서는 RPC와 비슷하다.

메시지를 직접 네트워크 연결로 전송하지 않고 임시로 메시지를 저장하는 메시지 브로커라는 중간 단계를 거쳐 전송한다는 점은 데이터베이스와 유사하다.

직접 RPC를 사용하는 방식보다 장점은?

- 메시지 브로커가 버퍼처럼 동작
- 메시지 유실 방지
- 송신자가 수신자의 IP주소나 포트번호를 알 필요 없다.
- 하나의 메시지를 여러 수신자로 전송할 수 있다.
- 논리적으로 송신자와 수신자가 분리 된다.

메시지 전달 통신은 일반적으로 단반향이라는 점이 RPC와 다르다. 즉 송신 프로세스는 대개 메시지에 대한 응답을 기대하지 않는다. 프로세스가 응답을 전송하는 것은 가능하지만 이것은 보통 별도 채널에서 수행한다. 이런 통신 패턴이 비동기다. 송신 프로세스는 메시지가 전달될 때까지 기다리지 않고 단순히 메시지를 보낸 다음 잊는다.

메시지 브로커는 보통 특정 데이터모델을 강요하지 않는다. 메시지는 일부 메타 데이터를 가진 바이트열이므로 모든 부호화 형식을 사용할 수 있다.

## 분산 액터 프레임워크

액터 모델(actor model)은 단일 프로세스 안에서 동시성을 위한 프로그래밍 모델이다. 스레드(경쟁 조건, locking, deadlock과 연관된 문제들)를 직접 처리하는 대신 로직이 액터에 캡슐화된다.

액터는 로컬 상태를 가질 수 있고 비동기 메시지의 송수신으로 다른액터와 통신한다.

분산 액터 프레임워크에서 이 프로그래밍 모델은 여러 노드 간의 애플리케이션 확장에 사용된다.

액터 모델은 단일 프로세스 안에서도 메시지가 유실될 수 있다고 이미 가정하기 떄문에 위치 투명성은 RPC보다 액터 모델에서 더 잘 동작한다.

분산 액터 프레임워크는 기본적으로 메시지 브로커와 액터 프로그래밍 모델을 단일 프레임워크에 통합한다.
