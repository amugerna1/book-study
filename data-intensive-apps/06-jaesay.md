# 6장. 파티셔닝(**Partitioning**)

큰 데이터베이스를 파티션이라는 작은 서브셋으로 나누고 각 파티션은 다른 노드에 할당한다. (샤딩이라고도 한다.)

데이터셋이 매우 크거나 질의 처리량이 매우 높다면 복제만으로는 부족하고 데이터를 파티션으로 쪼갤 필요가 있다.

데이터 파티셔닝을 원하는 주된 이유는 확장성이다.

파티셔닝이 고르게 이뤄지지 않아 다른 파티션보다 데이터가 많거나 질의를 많이 받는 파티션이 있다면 쏠렸다(skewed)고 말하며 불균형하게 부하가 높은 파티션을 핫스팟(hot spot)이라고 한다.

## 복제와 파티셔닝(**Partitioning and Replication)**

보통 복제와 파티셔닝을 함께 적용해 각 파티션의 복사본을 여러 노드에 저장한다.  

각 노드는 어떤 파티션에게는 리더로 어떤 파티션에게는 팔로워로 동작한다.

![그림 6-1](https://user-images.githubusercontent.com/19777164/193399994-cac4f0ac-aea0-4488-88ab-557d64c16b8c.png)

데이터베이스 복제에 관한 모든 내용은 파티션 복제에도 동일하게 적용되며 일반적으로 파티셔닝 방식과 복제 방식은 독립적으로 선택한다.

## 키-값 데이터 파티셔닝(**Partitioning of Key-Value Data)**

키-값 데이터 모델을 사용하여 쏠림현상이나 핫스팟을 줄이고 범위 스캔의 장점을 누릴 수 있다.

핫스팟을 완벽히 제거할 수는 없다. 항상 동일한 키를 읽고 쓰는 극단 적인 상황에서는 모든 요청이 동일한 파티션으로 쏠리게 된다(e.g. SNS의 유명인의 사용자 ID). 이럴 경우 (가장 간단하게는 키의 시작이나 끝에 임의의 숫자를 붙이고 관리하는 등) 현재 데이터베이스에서는 애플리케션에서 쏠림을 완화해야 한다.

### 키 범위 기준 파티셔닝(**Partitioning by Key Range**)
![스크린샷 2022-10-20 오후 4 23 10](https://user-images.githubusercontent.com/19777164/196883028-667d33f7-9443-411b-b44f-e7dd06ea5e43.png)

각 파티션에 연속된 범위의 키를 할당하는 것이다. 각 범위들 사이에 경계를 알면 어떤 키가 어느 파티션에 속하는 지 쉽게 찾을 수 있으며 어떤 파티션이 어느 노드에 할당됐는지 알면 적절한 노드로 요청을 보낼 수 있다.

키 범위 크기가 반드시 동일할 필요는 없다. 데이터를 고르게 분산시키려면 파티션 경계를 데이터에 맞게 조정해야한다.

각 파티션 내에는 키를 정렬된 순서로 저장할 수 있다. 이렇게 하면 범위 스캔이 쉬워지며 키를 연쇄된 색인으로 간주해서 질의 하나로 관련 레코드 여러개를 읽어오는데 사용할 수 있다.

### 키의 해시값 기준 파티셔닝(**Partitioning by Hash of Key**)

키에 적합한 해시 함수를 사용하여 각 파티션에 해시값 범위를 할당하고 해시값이 파티션 범위에 속하는 모든키를 그 파티션에 할당한다.

인접했던 키들이 모든 파티션에 흩어져서 정렬 순서가 유지되지 않아 범위 질의 효율성을 잃는다. 카산드라의 경우 테이블을 선언 할때 복합 키본키(compound primary key)로 지정하고 키의 첫 부분에만 해싱을 적용해 파티션을 결정하고 남은 컬럼은 데이터를 정렬하는 연쇄된 색인(concatenated index)으로 사용한다. 덕분에 첫 번째 컬럼에 고정된 값을 지정하면 키의 다른 컬럼에 대해서는 범위 스캔을 효율적으로 실행할 수 있다.

## 파티셔닝과 보조색인(**Partitioning and Secondary Indexes**)

보조색인은 관계형 데이터베이스의 핵심요소이며 문서데이터베이스에서도 흔하다. 솔라나 엘라스틱 서비 같은 검색 서버에게는 존재의 이유이다.

보조색인은 파티션에 깔끔하게 대응되지 않는 문제점이 있다. 보조 색인이 있는 데이터베이스를 파티셔닝하는데 널리 쓰이는 두가지 방법이 있다. 문서기반 파티셔닝(document-based partitioning)과 용어기반 파티셔닝(term-based partitioning)이다.

### 문서 기준 보조 색인 파티셔닝(**Partitioning Secondary Indexes by Document)**

![그림 6-4](https://user-images.githubusercontent.com/19777164/193415727-b9d2b66c-f989-4254-a569-8767c1d6d1cf.png)

보조 색인을 만들면 데이터베이스가 `color:red` 색인 항목에 해당하는 문서 ID를 매핑한다.

각 파티션은 자신의 보조 색인을 유지하며 그 파티션에 속하는 문서만 담당한다. 지역 색인(local index)라고도 한다.

모든 파티션으로 질의를 보내서 얻은 결과를 모두 모아야 한다. 이러한 방법을 스캐터/개더(scatter/gather)라고 하는데 보조 색인을 써서 읽는 질의는 큰 비용(꼬리 지연 시간 증폭(tail latency amplification))이 들 수 있다.

몽고DB, 리악, 카산드라, 엘라스틱 서치, 솔라클라우드, 볼트DB가 사용한다.

데이터베이스 벤더들은 대부분 보조 색인 질의가 단일 파티션에서만 실행되도록 파티셔닝 방식을 설계하기를 권장하지만 (단일 질의에서 여러 보조 색인을 사용할 때 등) 항상 가능하지는 않다.

### 용어 기준 보조 색인 파티셔닝(**Partitioning Secondary Indexes by Term**)

![그림 6-5](https://user-images.githubusercontent.com/19777164/193415732-bce5726c-78d8-4187-84b0-b45c2953e5eb.png)

각 파티션이 모든 파티션의 데이터를 담당하는 전역 색인(global index)이다.

모든 파티션에 있는 빨간색 자동차 정보는 색인 `color:red` 항목에 저장되지만 색깔 색인은 a부터 r까지의 글자로 시작하는 색깔은 파티션 0에, s부터 z까지의 글자로 시작하는 색깔은 파티션 1에 저장되도록 파티셔닝된다.

찾고자하는 용어에 따라 색인의 파티션이 결정되므로 이런 식의 색인을 용어 기준으로 파티셔닝됐다(term-partitioned)고 한다. 용어(term)라는 이름은 전문 색인(full-text indexes)에서 나왔는데 용어란 문서에 등장하는 모든 단어를 말한다.

색인을 파티셔닝할 때 용어 자체를 쓸 수도 있고 용어의 해시값을 사용할 수도 있다. 용어 자체를 쓰면 범위 스캔에 유리한 반면 해시값을 사용하면 부하가 좀 더 고르게 분산된다.

스캐터/개터를 할 필요가 없이 원하는 용어를 포함하는 파티션으로만 요청을 보내면 되기 떄문에 문서 파티셔닝 색인에 비해 읽기가 효율적이다. 하지만 단일 문서를 쓸 때 해당 색인의 여러 파티션에 영향을 줄 수 있기 때문에 쓰기가 느리고 복잡하다는 단점이 있다.

전역 보조 색인은 대개 비동기로 겡신되기 떄문에 색인 반영이 뒤쳐질 수 있다.

리악의 검색 기능과 오라클 데이터 웨어하우스에서 사용된다. 오라클 데이터 웨어하우스는 지역 색인과 전역색인  사이에서 선택할 수 있다.
## 파티션 재균형화(**Rebalancing Partitions**)

시간이 지나면 데이터베이스에 변화가 생긴다.

- 질의 처리량 증가해서 늘어난 부하를 처리하기 위해 CPU 추가해야 한다.
- 데이터셋 크기가 증가해서 데이터셋 저장에 사용할 디스크와 램을 추가해야 한다.
- 장비에 장애가 발생해서 그 장비가 담당하던 역할을 다른 장비가 넘겨받아야한다.

이런 변화가 생기면 데이터와 요청이 한 노드에서 다른 노드로 옮겨져야 한다. 클러스터에서 한 노드가 담당하던 부하를 다른 노드로 옮기는 과정을 재균형화(rebalancing)라고 한다. 파티션을 노드에 할당하는 방법을 파티션 재균형화라고 한다.

어떤 파티셔닝을 쓰는지에 무관하게 재균형화가 실행될 때 보통 만족시킬것으로 기대되는 최소 요구사항이 있다.

- 재균형화 후, 부하(데이터 저장소, 읽기 쓰기 요청)가 클러스터 내에 있는 노드들 사이에 균등하게 분배돼야 한다.
- 재균형화 도중에도 데이터베이스는 읽기 쓰기 요청을 받아들여야 한다.
- 재균형화가 빨리 실행되고 네트워크와 디스크 I/O 부하를 최소화할 수 있도록 노드들 사이에 데이터가 필요 이상으로 옮겨져서는 안된다.

### 재균형화 전략(**Strategies for Rebalancing**)

**쓰면 안되는 방법: 해시값에 모드 N연산을 실행(hash mod N)**

모드 N 방식의 문제는 노드 개수 N이 바뀌면 대부분의 키가 노드 사이에 옮겨져야 한다는 점이다. 이렇게 키가 자주 이동하면 재균형화 비용이 지나치게 커진다.

**파티션 개수 고정(Fixed number of partitions)**

![스크린샷 2022-10-03 오후 3 56 50](https://user-images.githubusercontent.com/19777164/193517986-656c2d95-f6eb-4c0b-878e-e451661ea36f.png)

파티션을 노드 대수보다 많이 만들고 각 노드에 여러 파티션을 할당하는 것이다.

노드 추가, 제거 시 파티션은 노드 사이에서 통째로 이동하기만 하면 된다.

데이터 전송이 진행중인 동안에 읽기 쓰기 처리는 기존에 할당된 파티션을 사용한다.

보통 데이터베이스가 처음 구축될 때 파티션 개수가 고정되고 이후에 변하지 않는다. 따라서 처음 설정된 파티션 개수가 사용 가능한 노드 대수의 최대치가 되므로 충분히 높은 값으로 선택해야 한다. 하지만 전체 데이터셋의 크기 변동이 심하다면 적절한 파티션 개수를 정하기 어렵다.

리악, 엘라스틱서치, 카우치베이스, 볼드모트에서 사용된다.

개별 파티션의 크기가 데이터셋 크기에 비례한다.

**동적 파티셔닝(Dynamic partitioning)**

HBase나 리싱크DB처럼 키 범위 파티셔닝을 사용하는 데이터베이스에서는 파티션을 동적으로 만든다. 파티션 크가가 설정한 값을 넘어가면 두개로 쪼개 원래 파티션의 절반 정도의 데이터가 저장되게 하고 반대로 파티션 크기가 임곗값 아래로 떨어지면 인전한 파티션과 합친다.

시작할 때 하나의 노드에 하나의 파티션이 있어 다른 노드들은 유휴(idle) 상태이게 되는 것을 방지하기 위해 HBase와 몽고DB에서는 빈 데이터베이스에 초기 파티션 집합을 설정할 수 있게 한다. 사전분할(pre-splitting)이라고 부른다.

키 범위 파티셔닝와 같이 해시 파티셔닝에서도 똑같이 사용될 수 있다.

파티션 개수가 데이터 셋에 비례한다.

**노드 비례 파티셔닝(Partitioning proportionally to nodes)**

파티션 개수가 노드 대수에 비례한다. 노드 당 할당되는 파티션 개수를 고정한다.

노드에 대수가 변함 없는 동안은 개별 파티션 크기가 데이터셋 크기에 비례해서 증가하지만 노드 대수를 늘리면 파티션 크기는 작아진다. 일반적으로 데이터 용량이 클수록 데이터를 저장할 노드도 많이 필요하므로 이 방법을 쓰면 개별 파티션 크기도 상당히 안정적으로 유지된다.

새 노드가 클러스터에 추가되면 해시 기반 파티셔닝을 사용하여 고정된 개수의 파티션을 무작위로 선택해 분할(일관성 해싱과 유사)하고 각 분할된 파티션 절반은 그대로 두고 다른 절반은 새 노드에 할당한다. 불균등한 분할을 피하기 위해 카산드라에서는 대안적인 재균형화 알고리즘이 추가됐다.

키산드라와 케타마(Ketama)에서 사용된다.

### 운영방법(Operations)

완전 자동 재균형화(fully automatic rebalancing)는 관리자의 개입이 전혀 없이 시스템이 자동으로 언제 파티션을 노드 사이에 이동할지 결정한다. 일상적인 유지보수에 손이 덜 가므로 편하하지만 예측하기 어렵다. 특히 자동 장애 감지와 조합되면 위험해질 수도 있다.

완전 수동 재균형화(fully manual rebalancing)는 관리자가 명시정으로 파티션을 노드에 할당하도록 설정하고 관리자가 재설정할 때만 파티션 할당이 변경된다. 느릴 수 있지만 운영상 예상치 못한 일을 방지할 수 있다.

완전 자동 재균형화와 완전 수동 재균형화 사이에 중간 지점이 있다. 자동으로 파티션 할당을 제안하지만 반영되려면 관리자가 확정해야 한다.

## 요청라우팅(**Request Routing**)

클라이언트는 요청을 보내려고 할 때 어느 노드로 접속해야 하는지 알 수 있어야 한다. 이 문제는 데이터베이스에 국한되지 않은 서비스 찾기(service discovery)의 일종이다. 요청을 올바른 노드로 라우팅하는 몇가지 다른 접근법이 있다.

1. 클라이언트가 아무 노드에나 접속하게 한다 (예를 들어 라운드로빈 로드 밸런서를 통해). 만약 해당 노드에 마침 요청을 적용할 파티션이 있다면 거기서 요청을 직접 처리할 수 있다. 그렇지 않으면 요청을 올바른 노드로 전달해서 응답을 받고 클라이언트에게 응답을 전달한다. 가십 프로토콜(gossip protocol)을 사용해서 클러스터 상태 변화를 노드 사이에 퍼뜨린다.
2. 클라이언트의 모든 요청을 라우팅 계층으로 먼저 보낸다. 라우팅 계층에서는 각 요청을 처리할 노드를 알아내고 그에 따라 해당 노드로 요청을 전달한다. 라우팅 계층에서는 아무 요청도 처리하지 않는다. 파티션 인지(partition-aware) 로드 밸런서로 동작할 뿐이다.
3. 클라이언트가 파티셔닝 방법과 파티션이 어떤 노드에 할당됐는지를 알고 있어야 한다. 이경우 클라이언트는 중개자없이 올바른 노드로 직접 접속할 수 있어야 한다.

![스크린샷 2022-10-03 오후 7 22 14](https://user-images.githubusercontent.com/19777164/193555279-203f02c6-3f02-479c-98e4-4aebd47699b1.png)

라우팅 계층(routing tier)이나 파티션 인지 클라이언트(partitioning-aware client) 같은 다른 구성요소들은 주키퍼(ZooKeeper)에 있는 정보를 구독할 수 있다.

![스크린샷 2022-10-03 오후 7 22 22](https://user-images.githubusercontent.com/19777164/193555317-0a7563a3-80b5-48c3-810e-b08bf9f8cdad.png)

### 병렬질의 실행 (Parallel Query Execution)

분석용으로 자주 사용되는 대규모 병렬 처리(massively parallel processing, MPP) 관계형 데이터베이스 제품은 훨씬 더 복잡한 종류의 질의를 지원한다.

MPP 질의 최적화기는 복잡한 질의를 여러 실행단계와 파티션으로 분해하며 이들 중 다수는 데이터베이스 클러스터 내의 서로 다른 노드에서 병렬적으로 실행될 수 있다.
