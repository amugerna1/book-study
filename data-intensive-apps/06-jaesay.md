# 6장. 파티셔닝(**Partitioning**)

큰 데이터베이스를 파티션이라는 작은 서브셋으로 나누고 각 파티션은 다른 노드에 할당한다. (샤딩이라고도 한다.)

데이터셋이 매우 크거나 질의 처리량이 매우 높다면 복제만으로는 부족하고 데이터를 파티션으로 쪼갤 필요가 있다.

데이터 파티셔닝을 원하는 주된 이유는 확장성이다.

파티셔닝이 고르게 이뤄지지 않아 다른 파티션보다 데이터가 많거나 질의를 많이 받는 파티션이 있다면 쏠렸다(skewed)고 말하며 불균형하게 부하가 높은 파티션을 핫스팟(hot spot)이라고 한다.

## 복제와 파티셔닝(**Partitioning and Replication)**

보통 복제와 파티셔닝을 함께 적용해 각 파티션의 복사본을 여러 노드에 저장한다.  

각 노드는 어떤 파티션에게는 리더로 어떤 파티션에게는 팔로워로 동작한다.

![그림 6-1](https://user-images.githubusercontent.com/19777164/193399994-cac4f0ac-aea0-4488-88ab-557d64c16b8c.png)

데이터베이스 복제에 관한 모든 내용은 파티션 복제에도 동일하게 적용되며 일반적으로 파티셔닝 방식과 복제 방식은 독립적으로 선택한다.

## 키-값 데이터 파티셔닝(**Partitioning of Key-Value Data)**

키-값 데이터 모델을 사용하여 쏠림현상이나 핫스팟을 줄이고 범위 스캔의 장점을 누릴 수 있다.

핫스팟을 완벽히 제거할 수는 없다. 항상 동일한 키를 읽고 쓰는 극단 적인 상황에서는 모든 요청이 동일한 파티션으로 쏠리게 된다(e.g. SNS의 유명인의 사용자 ID). 이럴 경우 (가장 간단하게는 키의 시작이나 끝에 임의의 숫자를 붙이고 관리하는 등) 현재 데이터베이스에서는 애플리케션에서 쏠림을 완화해야 한다.

### 키 범위 기준 파티셔닝(**Partitioning by Key Range**)

각 파티션에 연속된 범위의 키를 할당하는 것이다. 각 범위들 사이에 경계를 알면 어떤 키가 어느 파티션에 속하는 지 쉽게 찾을 수 있으며 어떤 파티션이 어느 노드에 할당됐는지 알면 적절한 노드로 요청을 보낼 수 있다.

키 범위 크기가 반드시 동일할 필요는 없다. 데이터를 고르게 분산시키려면 파티션 경계를 데이터에 맞게 조정해야한다.

각 파티션 내에는 키를 정렬된 순서로 저장할 수 있다. 이렇게 하면 범위 스캔이 쉬워지며 키를 연쇄된 색인으로 간주해서 질의 하나로 관련 레코드 여러개를 읽어오는데 사용할 수 있다.

### 키의 해시값 기준 파티셔닝(**Partitioning by Hash of Key**)

키에 적합한 해시 함수를 사용하여 각 파티션에 해시값 범위를 할당하고 해시값이 파티션 범위에 속하는 모든키를 그 파티션에 할당한다.

인접했던 키들이 모든 파티션에 흩어져서 정렬 순서가 유지되지 않아 범위 질의 효율성을 잃는다. 카산드라의 경우 테이블을 선언 할때 복합 키본키(compound primary key)로 지정하고 키의 첫 부분에만 해싱을 적용해 파티션을 결정하고 남은 컬럼은 데이터를 정렬하는 연쇄된 색인(concatenated index)으로 사용한다. 덕분에 첫 번째 컬럼에 고정된 값을 지정하면 키의 다른 컬럼에 대해서는 범위 스캔을 효율적으로 실행할 수 있다.
