# 8장 분산 시스템의 골칫거리

분산 시스템을 다루는 것은 한 컴퓨터에서 실행되는 소프트웨어를 작성하는 일과는 근본적으로 다르다.  
핵심적인 차이는 **뭔가 잘못될 수 있다는 것** 이며, 우리의 임무는 좀 잘못되더라도 제 역할을 해내는 시스템을 구축하는 것이다.

이번 장에서는 이런 문제점들을 살펴보며, 크게 3가지를 소개한다(해결책은 다음장에...).

1. 신뢰성 없는 네트워크(네트워크 문제)
2. 신뢰성 없는 시계(시계 및 타이밍 문제)
3. 지식, 진실, 그리고 거짓말(버그, 잘못 동작하는 노드)

<br/>

## 결함과 부분 장애

단일 컴퓨터에서 실행되는 프로그램은 소프트웨어가 제대로 작성되었다고 할 때, 보통 완전하게 동작하거나, 전체장애가 발생한다.

분산 시스템에서는 어떤 부분은 잘 동작하지만 다른 부분은 예측할 수 없는 방식으로 고장날 수 있다. 이를 **부분 장애(partial failure)** 라고 한다. 또한 같은 동작이더라도 예측할 수 없이 실패하는 경우도 있는데 이를 **비결정적** 이라 한다.

부분 장애를 고려하는것은 중요하다. 결함 처리는 소프트웨어 설계의 일부여야 하며, 결함이 발생하면 어떻게 동작할지도 알아야 한다.

<br/>

## 신뢰성 없는 네트워크

![img1](https://user-images.githubusercontent.com/32189698/198144745-aaba5722-9479-4959-ae95-af346b2a46a5.png)

네트워크상에서는 메시지가 언제 도착할지, 도착하기는 하는지가 보장되지 않는다. 메시지는 여러가지 이유로 손실/지연될 수 있다.  
클라이언트 입장에서는 위 3가지의 서로다른 상황(요청손실, 노드장애, 응답손실)에서 **왜 응답이 오지 않는지 알 수 없다.**

이 문제를 다루는 흔한 방법은 **타임아웃** 이다. 하지만 타임아웃을 적용하더라도 취소한 요청이 서버에 도달하는 경우도 있다는 점에 유의하자.



### 현실의 네트워크 결함

네트워크 결함의 원인은 상상도 못할정도(상어가 해저케이블을...)로 다양하다. 중요한점은 이 결함의 가능성을 인지하는것이다.

**네트워크 문제가 발생하면 어떻게 반응하는지 알고, 복구할 수 있도록 보장해야 한다.**  
고의로 네트워크 문제를 유발하고 시스템을 테스트하는것도 좋다.



### 타임아웃과 기약 없는 지연

서버(노드)의 상태를 체크할 수 있다면 좋겠지만 그것조차 확실하게 보장되지 않는다.  
결국 타임아웃 처리를 해야하는데, 그렇다면 **타임아웃은 얼마나 길어야할까?** 아쉽게도 간단한 답은 없다.

타임아웃은 짧으면 결함을 빨리 발견하지만, 원격 노드 부하로 응답이 느려졌을 경우에도 노드가 죽었다고 판단할 위험이 있다.  
죽지않은 노드를 죽었다고 판단하고 다른노드로 역할을 넘기면 다음과 같은 문제가 발생한다.

- 죽지않은 노드와 새 노드가 동작을 중복해서 실행할수도 있다.
- 과부하로 인한 응답지연일 경우 부하가 전파되어 연쇄 장애를 유발할 수 있다.

타임아웃을 적절하게 정하는 방법의 예시로 다음 방법이 있다.

- 응답시간 분포를 측정해서 장애감지지연 vs 이른타임아웃 사이에서 적절하게 지정
- 시스템이 응답시간과 [변동성(jitter)](http://www.ktword.co.kr/test/view/view.php?m_temp1=991)를 측정해서 동적으로 조절(TCP 패킷 재전송도 이처럼 동작)  
   https://aws.amazon.com/ko/blogs/architecture/exponential-backoff-and-jitter/  
   https://jungseob86.tistory.com/12



#### 네트워크 혼잡과 큐 대기

![img2](https://user-images.githubusercontent.com/32189698/198144776-c652e9e6-3156-4bdf-aabc-89822055e5b0.jpg)

여러 노드가 동시에 같은 목적지로 패킷을 보내면 네트워크 스위치는 패킷을 큐에 넣고 처리한다.  
큐가 꽉 차면 패킷이 유실될 수 있다. 스위치 외에도 큐가 여러곳에 존재하는데 책을 참고하자.


네트워크 지연을 예측하려는 방법은 대부분 한계가 있고, 현재로서는 **네트워크 지연과 신뢰성에 대해 어떤 보장도 할 수 없다.**  
네트워크 혼잡, 큐 대기, 기약 없는 지연이 발생할 가능성을 생각해야 하며, 타임아웃은 실험을 통해 결정해야 한다.

<br/>

## 신뢰성 없는 시계

애플리케이션은 타임아웃, 응답시간, 성능분석, 기능구현 등 여러 방면으로 시계에 의존한다.  
**각 장비는 자신의 시계를 갖고있음** 에 유의하며 이번 장을 살펴보자.

분산 시스템에서는 통신이 즉각적이지 않기 때문에 시간을 다루기 까다롭다.  
일반적으로 NTP(네트워크 시간 프로토콜)서버를 통해 각 장비의 시계를 조정한다.


### 단조 시계 대 일 기준 시계

컴퓨터는 **일 기준 시계, 단조 시계** 두 가지 종류의 시계를 갖고 있다.

- **일 기준 시계(time-of-day clock): 흔히 아는 벽시계 시간. 보통 NTP로 동기화된다.**  
  ex. Linux/clock_gettime(CLOCK_REALTIME), Java/System.currentTimeMillis()
- **단조 시계(monotonic clock): 장비 내 타이머에 의해 경과 된 시간.**  
  ex. Linux/clock_gettime(CLOCK_MONOTONIC), Java/System.nanoTime()


### 시계 동기화와 정확도

![img3](https://user-images.githubusercontent.com/32189698/198147665-f2b9dff1-1383-4105-aa40-d2ac12dd4988.png)

아쉽게도 두 시계 모두 기대만큼 신뢰성을 보장하지는 않는다.

- 컴퓨터의 쿼츠 시계는 장비의 온도에 따라 더 빠르거나 느려질 수 있다(드리프트(drift) 현상)
- 로컬시계가 NTP서버와 너무 차이가 나면 로컬 시계가 리셋될 수 있다.
- 노드와 NTP서버간 방화벽이 막혀 노드가 한동안 잘못된 설정으로 돌아갈 수 있다.
- NTP 동기화 오차는 네트워크 성능에 영향을 받는다.
- NTP서버에 이상이 있을수도 있다.
- [윤초](https://ko.wikipedia.org/wiki/윤초)가 발생하면 이를 고려하지 않은 시스템은 오동작할 수 있다.
- 가상 장비에서 CPU 공유로 인해 VM간 시간차이가 발생할 수 있다.
- 사용자가 고의로 시간을 바꿀수도 있다.


### 동기화된 시계에 의존하기

네트워크에 결함이 있다는것을 인지하듯이 시계 역시 잘못될 수 있다는점을 인지해야 한다.

시계 오류는 티가 잘 안나기 때문에 티 안나는 데이터 손실이 발생할 수 있다.  
따라서 동기화 된 시계가 필요한 소프트웨어를 사용한다면 장비 사이의 시계 차이를 주의깊게 모니터링해야 한다.  
다른 노드와 시계 차이가 큰 노드는 죽은 것으로 선언하고 클러스터에서 제외해야 한다. 


#### 이벤트 순서화용 타임스탬프

![img4](https://user-images.githubusercontent.com/32189698/198144877-8ba45edd-31e6-4d38-a2ec-3a125a224043.png)

위 그림은 데이터베이스에서 일 기준 시간을 위험하게 쓰는 예시다.

1. 클라이언트A가 노드 1에 `x = 1`
2. 해당 쓰기를 노드 3으로 복제
3. 클라이언트B가 노드 3에 `x += 1`
4. 두 쓰기를 노드2로 복제

위 순서대로 진행하면 클라이언트B가 더 늦게 쓰기 때문에 `x`는 `2`여야 하지만 결과는 `1`이 된다.  
즉 클라이언트B의 증가 연산은 손실되는것이다.

이런 문제를 없애고자 최종쓰기승리(last write wins, LWW)와 같은 방법도 있지만 이 역시 로컬 일 기준 시계에 의존한다.  
증가하는 카운터를 기반으로 논리적 시계를 써서 이벤트 순서를 안전하게 보장할 수 있지만

여기서도 역시 해결하는것보다는 **시계는 틀릴 수 있다** 는 점을 생각하는게 중요하다.  
구글 스패너의 트루타임(TrueTime) API의 응답값인 ``를 보고 시계의 불확실성을 생각해낼 수 있어야 한다.


#### 전역 스냅숏용 동기화된 시계

구글 [스패너(분산DB)](https://en.wikipedia.org/wiki/Spanner_(database))는 구글 트루타임(TrueTime) API의 신뢰구간 값(`[earliest, latest]`)을 활용해서 시간의 불확실성을 해소했다.  
신뢰구간이 겹치지 않으면 순서를 명확히 확인할 수 있다는 점을 활용한다.

<br/>

## 지식, 진실, 그리고 거짓말

네트워크에 있는 노드는 어떤 것도 확실히 **알지** 못한다. 응답이 없는게 네트워크 문제인지, 노드 자체의 문제인지 확실히 구별할 수 없다.  
분산 시스템에서 우리는 동작에 대한 가정을 명시하고 이를 기반으로 신뢰성 있는 동작을 달성할 수 있다.

### 진실은 다수결로 결정된다

여러 분산 알고리즘은 정족수(quorum), 즉 노드들 사이의 투표에 의존한다.  
특정 노드 하나에 대한 의존을 줄이기 위해 결정하려면 여러 노드로부터 어떤 최소 개수의 투표를 받아야 한다.

정족수를 이룬 노드들이 다른 노드를 죽었다고 선언하면 그 노드는 여전히 살아 있더라도 죽은 것으로 간주되어야 한다.  
그 개인 노드는 정족수를 이룬 결정에 따라서 물러나야 한다.

#### 리더와 잠금

분산시스템에서 노드에 특별한 권한(리더 등)을 줄 때는 주의해야 한다.  
노드가 죽었다고 판단되었음에도 해당 노드가 살아서 마음대로 권한을 행사한다면 문제를 유발할 수 있다. 

예를 들어 저장 서비스에 있는 어떤 파일을 한 번에 클라이언트 하나씩만 접근하는 프로그램을 만든다고 하자.  
아래 그림은 클라이언트가 그 파일에 접근하기 전에 잠금 서비스로부터 임차권(lease)을 얻도록 해서 기능을 구현했다.

![img5](https://user-images.githubusercontent.com/32189698/198144947-ad95f490-d7db-4544-b03a-b285f863f70b.png)

1. 클라이언트1이 락을 획득 후 일시중단되었다.
2. 잠금 서비스는 클라이언트1이 죽었다고 판단하고 클라이언트2에게 락을 부여했다.
3. 클라이언트2가 파일쓰기를 수행했다.
4. 중단된 클라이언트1이 살아나서 쓰기를 수행했다.

결과적으로 클라이언트들의 쓰기가 충돌되고 파일이 오염된다.

#### 펜싱 토큰

이런 멋대로인 노드가 시스템을 방해할 수 없도록 하는 단순한 기법으로 **펜싱(fencing)** 이 있다.

![img6](https://user-images.githubusercontent.com/32189698/198145081-639a0f09-f232-41e2-9a52-28166bc15a23.png)

잠금 서비스가 임차권(lease)을 부여할때마다 **펜싱 토큰(fencing token)** 도 반환하도록 하자.  
스토리지는 자신이 처리한 쓰기작업의 토큰번호(34)를 기억해뒀다가 오래된 토큰(33)이 올 경우 쓰기를 거부한다.

앞선 사례와는 다르게 클라이언트1은 토큰이 만료되어 쓰기를 진행하지 못했다.  
서버 측에서 토큰을 확인하는 것은 대체로 좋다.

### 비잔틴 결함

펜싱 토큰은 부주의에 의한 오류에 빠진 노드를 감지하고 차단할 수 있다. 하지만 고의로 가짜 토큰을 보내는 노드에는 취약하다.  
노드가 받지 않은 메시지를 받았다고 하는 등의 "거짓말"을 할지도 모른다는 점이 분산 시스템 문제를 더 어렵게 만든다.

이런 동작을 **비잔틴 결함(Byzantine fault)** 이라고 하며, 이런 신뢰할 수 없는 환경에서 합의에 도달하는 문제를  
**[비잔틴 장군 문제(Byzantine Generals Problem)](https://ko.wikipedia.org/wiki/두_장군_문제)** 라고 한다.

비잔틴 내결함성을 가지는 프로토콜을 만드는 것은 매우 복잡하며, 블록체인과 같은 P2P 네트워크에 적절하다.

일반적으로 우리의 데이터센터에서는 조직에서 모든 노드를 제어하기 때문에 노드를 신뢰할 수 있고,  
클라이언트의 행동이 허용된것인지 결정하는 권한(인증, 접근제어, 암호화, 방화벽 등)을 서버에게 주는 것으로 충분하다.

#### 약한 형태의 거짓말

신뢰할 수 있는 노드일지라도 하드웨어 문제, 소프트웨어 버그 등 약한 형태의 "거짓말"은 할 수 있다.  
따라서 이를 보호해주는 메커니즘을 소프트웨어에 추가해주는것도 좋다.

- 네트워크 패킷은 때때로 오염되는데, TCP와 UDP에 내장된 체크섬으로 검출되지만 검출을 피하는 경우도 있다.  
  보통 애플리케이션 수준 프로토콜에서 체크섬을 쓰는 방식으로 해결된다.
- 공개적으로 접근 가능한 애플리케이션은 사용자 입력을 신중하게 검사해야 한다.
- NTP 클라이언트는 여러 서버 주소를 설정해서 서버 한 대를 쓸 때보다 견고해질 수 있다.

### 시스템 모델과 현실

분산 시스템 문제를 해결하기 위해 많은 알고리즘이 설계되고 있다.  
이러한 알고리즘이 특정 하드웨어/소프트웨어에 심하게 의존되지 않도록 **결함의 종류를 시스템 모델로 정형화** 한다.

- 타이밍 가정 모델: 동기식 모델, 부분 동기식 모델, 비동기식 모델
- 노드 장애 모델: crash-stop 결함 모델, crash-recovery 결함 모델, 비잔틴 결함 모델

<br/>

## 정리

문제에 대해 비관적으로 생각해서 많은 부분을 고려해야 한다.

- **부분장애를 발생 시 동작을 고려하자** / 결함과 부분 장애
- **네트워크는 신뢰할 수 있는가** / 신뢰성 없는 네트워크
- **시계는 신뢰할 수 있는가** / 신뢰성 없는 시계
- **노드는 신뢰할 수 있는가** / 지식, 진실, 그리고 거짓말
