# 01 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션
****
## 오늘날의 많은 애플리케이션은 "데이터중심(data-intensive)"적이다.
****

Application의 경우 CPU의 성능은 더이상 제한요소가 아니다.
* 관심사 : 데이터의 양, 데이터의 복잡도, 데이터의 변화속도

### 데이터 중심 어플리케이션의 구성요소
* 데이터 저장 : 데이터베이스
* 데이터 읽기
  * 읽기속도 향상을 위한 구성 : 캐시
  * 사용자의 복잡한 요구사항에 맞춘 빠른 검색, 필터링 : 검색색인( search index )
* 데이터 처리
  * 데이터의 비동기 처리를 위해 다른 프로세스로 메시지 보내기 : Stream processing
  * 주기적의로 데이터를 누적하여 분석 : batch processing    

### 현실문제
* 사용자의 요구사항에 따른 데이터베이스 시스템의 선택 및 구성 : 캐싱방법, 검색색인 방법 or 복합구성

****
## 데이터 시스템에 대한 생각
****

### 데이터 시스템이란?
데이터 베이스, 큐, 케시 모두가 데이터 시스템이다.

* 전통적 분류와 다른 데이터 시스템 : 기본 기능 + feature => 새로운 요구사항
  * 메시지 큐로 사용하는 데이터스토이인 Redis
  * 데이터베이스 처럼 지속성을 보장하는 메시지 큐인 아파치 카프카

### 현실문제1 : 하나의 도구로는 만족시킬수 없는 요구사항
<img width="500" alt="image" src="https://user-images.githubusercontent.com/5934737/185275353-2c32c47f-34db-4ef7-b4f3-f415e0ceb4c1.png">

* 데이터 베이스는 메인데이터 베이스와 분리된 캐시계층유지 필요
* Elasticsearch나 solr같은 전문(full-text) 검색 서버의 경우 메인 DB 와 동기화된 캐시나 색인을 유지하는 것은 Application 코드의 책임
* 개발자는 결국 Client에게 구현을 숨기고 일관된 결과를 제공받을수 잇도록 서비스를 제공해야한다.
   * 캐시의 데이터의 생성, expiration time, update등을 고려해야한다. 어플리케이션 개발자는 데이터 시스템의 설계자이기도하다.

### 현실문제2 : 데이터시스템 설계자로서의 추가고민
* 내부적으로 문제가 있어도 데이터를 전확하고 완전하게 유지하려면 어떻게 해야할까?
* 시스템의 일부성능이 저하되더라도 클라이언트에 어떻게 좋은 성능을 제공할까?
* 부하증가를 다루기 위해 어떻게 규모를 확장할까?
* 서비스를 위해 좋은 API는 어떤 모습일까?

****
## 신뢰성
****
" 하드웨어나 소프트웨어 결함, 심지어 인적오류에 직면하더라도 시스템은 지속적으로 올바르게 동작해야한다. "

### 개념
"무언가 잘못되더라도 지속적으로 올바르게 동작함"

> 결함 : 잘못될 수 있는 일

> 내결함성, 탄력성 : 결함을 에측하고 대처할 수 있는 시스템

> 장애 : 사용자에게 서비스를 제공하지 못하고 시스템이 멈춘경우

결함으로 장애가 발생하지 않도록 내결함성을 가지는 것이 중요하다
고의적으로 결함을유도함으로써 내결함성을 지속적으로 훈련하고 테스트하자. 
( 참고 : 'nexflix, Chaos Monkey' -  https://effortguy.tistory.com/165 )

### 하드웨어 결함
하드디스크의 평균 장애시간 : 10~50년 => 25년마다 하드디스크 장애발생가능성

* 장애극복을 위한 대응
  * RAID 구성 : 중복구성
  * 이중전원, 핫 스왑가능한 CPU
  * 데이터 센터내 건전지 및 디젤 발전기

소프트웨어 내결함성 기술을 사용하거나 하드웨어 중복성을 주가해 전체 장비의 손실을 줄이는 쪽으로 구성한다.
장비를 재부팅 및 업그레이드시 시스템의 중단을 없앤다는 장점이 있다.

### 소프트웨어 오류
아래와 같은 소프트웨어오류의 예시들이 있다.
* 리눅스 커널의 버그로 인해 많은 어플리케이션이 멈춰버린 2012년 6월 30일 윤초사건
* CPU, 메모리, 디스크공간 네트워크등 공유자원을 과도하게 사용하는 프로세스
* 시스템의 속도가 느려져반응이 없거나 잘못된 응답을 반환하는 서비스
* 한구성요소의 작은 결함이 다른 구성요소의 결험으로 연쇄장애를 일으킴

### 해결방안
* 시스템의 가정과 상호작용에 대해 주의깊게 생각하기
* 빈틈없는 테스트
* 프로세스 격리
* 죽은 프로세스의 재시작 허용
* 프로덕션환경에서 시스템 동작의 측정
* 모니터링분석하기

### 인적오류
대규모 인터넷 서비스에 대한 인적오류가 주요원인으로 하드웨어결함은 10~25%이다.

### 해결
* 오류의 가능성을 최소화하는 방양으로 시스템을 설계하라 : 잘설계된 추상화, API, 관리 I/F를 사용하라.
* 비프로덕션 샌드박스를 제공하라 : 실제데이터를 사용해 안전하고 실험해볼수 잇는 환경
  (참고 - https://experienceleague.adobe.com/docs/experience-platform/sandbox/home.html?lang=ko)
* 철처하게 테스트하라
* 장애발생시 빠르게 복구할수잇는 환경을 만들어라.
* 성능지표와 오류 로그등을 모니터링할 수 잇는 환경을 마련하라.

****
## 확장성
****
"시스템의 데이터의 양, 트래픽양, 복잡도가 증가하면서 처리할수 잇어야한다.

### 부하기술하기 

* 부하의 지표들
  * TPS, Database read/time ratio, Active User, Cache hit ratio

### 트위터의 예
#### User Story
* 트윗작성 : 사용자는 팔로워에게 새로운 메시지를 게시할 수 있다. ( 4.6k req/s, peak time 12k req/s )
* 홈 타임라인 : 사용자는 팔오우한 사람이 작성한 트윗을 볼 수 있다. ( 300k req/s )

#### 문제점
* fan out 현상 : input, output 의 심각한 비대칭현상. ( 참고 : https://gdnn.tistory.com/88 )

#### 구현 history
* Versoin1 : 홈라인구성
```java
SELECT tweets.*, users.* FROM tweets JOIN users ON tweets.sender_id = users.id

JOIN follows ON follows.followee_id = users.id WHERE follows.follower id = current user
```
  
  * 문제점 : Heavy query

* version2 : 개별로 각 사용자의 홈라인 캐시를 유지한다. 트윗작성후 각자의 타임라인 캐시에 새로운 트윗을 삽입한다.
<img width="738" alt="image" src="https://user-images.githubusercontent.com/5934737/185282079-11119a77-34c3-4fc5-a92b-58d0b1bc3baf.png">

  * 문제점 : 일부 인플루언서의 경우 굉장히 많은 쓰기가 발생, 3천만건이상의 쓰기가 발생할 수도 잇다.

* version3 : hybrid형태로 홈라인구성시점에 별도로 가져와서 합치는 형태

<img width="737" alt="image" src="https://user-images.githubusercontent.com/5934737/185282422-365ecaad-05ca-4fe3-b181-8cd8d0bdd998.png">

### 성능기술하기
* 부하테스트의 Test case 유형 : 
  * 시스템자원(CPU, Memory, N/W bandwidth)를 유지하고 시스템성능 영향파악
  * 시스템자원증가시키면서 시스템성능 영향파악

* 성능 수치
  * throughput 초당 처리건수
  * response time : 응답시간

* 성능측청결과 후 고려사항
  * outlier
  * tail latency : 10000건중 느린 1건의 최적화에는 비용이 많이 증가한다.
  * 서비스 수준목표( service level objective, service level agreement ) 를 고려한다.
  * 큐지연 : 선두차단.

### 부하대응 접근방식
* vertical scaling vs horizontal scaling : 용량확장(단일머신) vs 규모확장(여러머신)
* stateless vs statful 의 배포 확장 : stateful 의 추가고려사항 많음.
---
****
## 유지보수성
****
" 시간이 지나면서 시스템에 다양한 작업을 진행할때 생산적으로 진행될 수 잇어야한다. "

* 주요 용어들
  * 운용성 : 운영팀이 운영하기 원활하게 만들어라
  * 단순성 : 복잡도를 최대한 단순화하자
  * 발전성 : 변경하기 용이하도록 하자.

### 운용성 : 운영의 편리함만들기 
* 시스템 모니터링, 장애 성능저하등의 원인 추적 용이성
* 보안패치 최신
* 배포, 설정관련한 도구 및 사례마련
* 담당자 퇴사/이동등에도 조직의 지식 보존
### 단순성 : 복잡도 관리
* big ball of mud : 하나의 시스템을 매우 복잡하고 어렵게 만드는 경우
* 추상화를 통해서 구현을 재 사용하도록 한다.
### 발전성 : 변화를 쉽게 만들기
* 애자일 작업패턴 : TDD, refactoring

---

## 정리
