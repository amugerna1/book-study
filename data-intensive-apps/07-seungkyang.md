# 7장. 트랜잭션
현실세계의 시스템에서 벌어질 수 있는일.
- 데이터 베이스 소프트웨어나 하드웨어는 언제라도 실패할 수 있다.
- 어플리케이션은 실행도중 언제라도 죽을 수 있다.
- 네트워크가 끊기면 어플리케이션과 데이터베이스의 연결이 갑자기 끊기거나 DB 사이의 통신이 불가할 수 있다.
- 여러 client가 DB에 동시에 쓰기를 실행하여 다른 클라이언트가 쓴 내용을 덮어쓸 수 있다.
- 클라이언트가 부분적으로만 갱신되서 비정상적인 데이터를 읽을 수 있다.
- client의 race condition은 예상하지 못한 버그를 발생시킬 수 있다.

트랜잭션의 개념이 무엇일까?
- 몇개의 읽기와 쓰기를 하나의 논리적 단위로 묶는 방법
- 전체가 성공(commit) 하거나 실패(abort, 롤백)한다.

트랜잭션의 사용 이유
- 오류 부분적인 실패를 걱정할 필요가 없다.
- 동시성 문제의 해결할 수 있다.
- 어떤 경우는 트랜잭션을 완화/사용않는 것이 안전/성능상의 이점이 있다

그렇다면, 트랜잭션이 필요한지에 대한 판단을 할필요가 있다.
이를 위해 트랜잭션이 제공하는 안정성보장의 실체가 무엇인지, 이에 따른 비용은 무엇인지 정확한 이해/판단이 필요하다.

데이터베이스에서 제공하는 알고리즘기준으로 아래와 같은 문제를 논의한다.
- 동시성 문제
- race condition
- 격리 수준의 구현 : read commited, snapshot isolation, serialization

8장에서는 분산에서의 난제를 확인, 7장에서는 단일 분산 시스템에서 확인한다.

## 1. 애매모호한 트랜잭션의 개념
### 새로 등장한 NoSQL vs 전통적인 RDB 사이의 트랜잭션 상이한 접근법
- 전통적인 RDB : "값진 데이터"가 있는 "중대한 애플리케이션"에 필수적인 요구사항이다.
- 새로 등장한 NoSQL : 분산환경에서 높은 성능과 고가용성을 유지하려면 트랜잭션을 포기해야한다.
 두 관점 모두 완전한 과장이다.
 
### ACID의 의미
트랜잭션이 제공하는 안전성 보장은 흔히 원자성(Atomicity), 일관성(Consistency), 격리성(Isolation), 지속성(Durability)로 알려져잇다.
상위 수준의 아이디어는 견실하지만 하지만 이의 구현은 현실 세계에서 데이터베이스마다 제각각이다.

각각의 개념을 살펴보자.

### 원자성이란?
클라이언트가 쓰기 작업 몇개를 실행하려고하는데 그 중일부만 처리된 후 결함이 생기면(예상치못한 종료등) 여러쓰기작업이 하나의 원자적 트랜잭션으로 묶여잇으므로 완료(커밋) 될 수 없다면,
Abort되고 데이터 베이스는 트랜잭션에서 지금까지 실행한 쓰기를 무시하거나 취소해야한다.

원자성의 결국, 원장성의 범위를 정의하고 트랜잭션이 Abort되었다면 어플리케이션에서 어떤 것도 변경되지 않은것으로 판단하여 안전하게 재시도 할 수 잇는 것이다.
( Abortbility)이 원자성보다 나은단어다.

### 일관성이란?
- 5장에서 복제일관성과 비동기식으로 복제되는 시스템에서 발생하는 최종적 일관성문제에 대해 설명했다
- 일관성해싱은 어떤 시스템들에서 재균형화를 위해 사용하는 파티셔닝 방법이다.(204p)
- ACID의 맥락에서 일관성은 DB가 "좋은 상태"에 있어야한다는 것의 애플리케이션에 특화된 개념을 가리킨다.
위와 같이 굉장히 많은 의미가 있다.

불변식,
회계시스템의 모든 계좌에 걸친 대변과 차변은 항상 맞아떨어져야한다.

하지만, 이를 위해서 DB는 보장할 수 있는게 없고, 이는  Application의 책임이다.
일관성은 Application의 책임이며 나머지는 DB의 책임이다.

### 격리성이란?
<img width="698" alt="get counter" src="https://user-images.githubusercontent.com/5934737/195339756-e2a385dc-e38d-4a6a-ad12-6a6763461292.png">
race condition에 놓인 상황에 43이 되었다.

격리성은 트랜잭션은 다른 트랜잭션을 방해 할 수 없는 것을 말한다. 즉, 여러 트랜잭션이 동시에 실행되었더라도 그 결과가 순차적으로 실행되엇을 때와 결과가 동일해야함을 말한다.

### 지속성이란?
트랜잭션이 성공적으로 커밋되었다면 하드웨어 결함이 발생하거나 데이터베이스가 죽더라도 트랜잭션에서 기록한 모든 데이터는 손실되지 않는다라는 보장이다.
지속석을 보장한다는 의미는 commit 전 다른 노드의 복제완료까지를 의미한다.

### 단일 객체 연산과 다중객체 연산
격리성 위반의 예로 : 트랜잭션이 커밋되지 않은 데이터를 읽은 ("Dirty read") 경우이다.
<img width="489" alt="image" src="https://user-images.githubusercontent.com/5934737/195343969-539d7d76-2ba1-44d0-80ae-c3b8fd6651bb.png">
- 않읽은 메시지의 수를 보여주기 위해 별도의 필드로 관리하는 경우(비정규화) 별도의 필드 업데이트도 하나의 트랜잭션에 포함되어야한ㄷ.

원자성이 보장되어야하는 이유는 우편함 삽입동작과 안읽은 메시지 개수동작이 유지가 동기화되어야하는데, 개수갱신을 실패하면 트랜잭션이 어보트되고 삽입된 이메일은 롤백되어야한다.
<img width="493" alt="image" src="https://user-images.githubusercontent.com/5934737/195344618-4f31bfb8-6d6f-4a6f-acf4-a4e92a0f70f4.png">

다중 객체 트랜잭션은 그래서 동일한 트랜잭션내의 연산이 하나로 블럭화 되어야하는데, 관계형 데이터 베이스에서 이것은 전형적으로 TCP 연결을 기반으로 한다.
BEGIN TRANSACTION + COMMIT의 Pair를 하나의 트랜잭션으로 본다.

#### 단일 객체 쓰기( 원자성 격리성의 적용 )
???
#### 다중 객체 트랜잭션의 필요성
많은 분산시스템에서 포기했다. 키-값이터 모델과 단일객체연산만을 사용해서 애플리케이션 구현이 가능할까? 많은 경우에 다중객체트랜잭션은 필요하다.
- FK는 참조가 유효한 상태를 보장한다. 서로 참조하는 여러 레코드 삽입시 동기화는 중요하다.
- 한번에 여러문서를 갱신하는 경우는 허다하며 데이터 동기화가 필요하므로 트랜잭션이 유용하다.
- 서로다른 데이터베이스를 갱신하는 경우 트랜잭션이 보장되어야한다.

#### 오류와 어보트 처리
트랜잭션의 핵심은 오류가 생기면 Abort 후 안전하게 재시도 할 수 있다는 것이다.
ACID Database는 이 철학을 바탕으로 이를 위반하는 경우 트랜잭션을 완전히 폐기한다. 하지만, 모든 시스템이 이를 따르지 않고 리더없는 복제를 사용하는 데이터스토어는 이를 Application의 책임으로 위임한다.
Rails or Django는 ORM framework는 Abort 트랜잭션을 재시도 하지 않는다.
ABORT된 트랜잭션을 재시도하는 것은 간단하고 효과적인 오류 처리 메커니즘이지만 완벽하지는 않다.
- 트랜잭션은 성공햇으나 커밋성공을 알리는 도중 실패할 경우 두번실행될 수 있다.
- 과부하관련 오류는 트랜잭션 재시도로 인해 악화될 수 있다.( 재시도 횟수등으로 제어 )
- 일시적인 오류( 교착상태, 격리성 위반, 네트워크 단절, 장애복구)만 재시도 가지가 있고 영구적인 오류(제약조건위반)은 재시도 해도 소용이 없다.(char <-> int )
- 여러개의 다른 시스템이 함께 abort/commit되게 만들고 싶다면 351page에서 다루게 될 것 이다.

### 완화된 격리 수준
동시성문제는 공유자원에 접근할때 생기는데, 드물게 발생할 수 있기에 재현이 어려운 경우가 많다.
그래서 데이터베이스는 오랫동안 트랜잭션 격리를 제공함으로써 어플리케이션 개발자들에게 동시성 문제를 감추려고 햇다.(Wow)
직렬성 격리는 여러 트랜잭션이 직렬적으로 실행되어 동일한 결과를 얻음을 보장하는데, 현실에서는 완화된 격리수준을 사용한다.
그런데 이는 금전적인 손실을 가져오기도 하고 재무감사원의 감사도 받게하고 고객의 데이터를 오염시키는 경우도 있다.

인기있는 관계형 데이터 베이스 조차도 완화된 격리성을 사용하는 경우가 많다.

그래서 우리는 존재하는 동시성 문제를 이해하고 방지하는 법을 배우고 올바른 애플리케이션을 만들 수 있다. ( 책에 더 깊은 내용은 문헌 참조 권유 )

#### 커밋 후 읽기( Read Commit )
가장 기본적인 수준의 트랜잭션 격리로 아래 두가지를 보장한다.
- 데이터 베이스에서 읽을 때 커밋된 데이터만 읽는다 ( no, dirty read )
- 데이터 베이스에서 쓸 때 커밋된 데이터만 쓴다. ( no, dirty write ) 

##### 더티읽기 방지
트랜잭션이 쓴 내용은 커밋된 후에야 다른 트랜잭션에서 보인다는 뜻이다.
<img width="502" alt="image" src="https://user-images.githubusercontent.com/5934737/195352042-b0d7d4b0-fb98-40bd-b970-b49380387a14.png">
사용자 1은 x=3을 썻지만 사용자 2의 get X는 사용자 1이 커밋하지 않았으므로 여전히 2를 반환한다.

유용성
- dirty read는 트랜잭션들이 서로 다른 값을 읽게되는 것을 방지한다. dirty read는 다른 트랜잭션들이 잘못된 결정을 하게 만들 수 있다.
- 트랜잭션이 rollback되면 dirty read는 커밋되지 않을 데이터를 보게 된다. 이는 매우 안좋은 결과를 낳을 수 있다.

##### 더티쓰기 방지
먼저 쓴 트랜잭션이 commit/abort 될 때까지 두번째 쓰기를 지연시키는 방법을 사용한다.

<img width="515" alt="image" src="https://user-images.githubusercontent.com/5934737/195352951-b888e0ae-04ba-480e-bd2d-6b4ab2b8e3a2.png">

- 트랜잭션이 다중객체를 갱신하면 나쁜결과를 유발할 수 있다. 그림에서 목록테이블과 송장테이블에 대한 두번의 갱신이 필요하나 커밋전 읽기는 판매는 밥에게 송장은 앨리스에게 발송되는 사고가 생긴다.
커밋 후 읽기는 이러한 사고를 막아준다.
- 하지만, 커밋 후 읽기는 카운터증가 사이의 경쟁조건은 막지못한다.(그림 7-1) 즉, 첫번째 트랜잭션이 커밋된 후 두번째 쓰기가 일어낫기에 Dirty write는 아니지만 이유가 다르다( 242page에서 다른다.)

##### 커밋 후 읽기 구현
더티쓰기를 막기 : 데이터베이스에서는 변경시 raw lock을 건다. 그래서 오직 한트랜잭션만 변경이 가능하다.
더티읽기를 막기 : 읽을 트랜잭션이 lock을 획득하고 바로 해제한다. 그 후에는 쓰기를 실행한 트랜잭션이 lock을 가지고 잇을 것이다.(commit 후 풀릴것이다.)
하지만 현실에서는 여러 트랜잭션이 대기해야하기 때문에 그림 7-4의 방법으로 commit 전 데이터를 응답한다.

##### 스냅숏 격리와 반복 읽기
"커밋 후 읽기"를 적용하면 많은 문제가 해결된다. 하지만 아직 버그는 존재한다.
<img width="495" alt="image" src="https://user-images.githubusercontent.com/5934737/195356929-a7f98f85-8989-4691-9ee1-25740266ee70.png">
앨리스는 총 1000달러가 두 계좌에 500달러씩 나눠놓앗을때 100달러를 하나의 계좌에서 다른계좌로 이체하는 순간에 불운하게도 트랜잭션이 처리되고 있는 순간에 계좌잔고를 보개되면 입금되지 전 계좌와 출금 후의 계좌를 동시에 보게되면 900달러로 보일 수 있다( 100달러 없어짐 )

이런 현상은 nonrepeatable read(비반복읽기) || read skew(읽기 스큐)라고 한다. 받아들일 수 있는 정도의 문제이다. 곧 해결될 것이기 때문이다.

그런데 이러한 일시적인 관성을 감내하기 어려운 경우가 있다.

###### 백업
데이터 베이스에 대한 복사본을 만들시 백업프로세스가 실행되는 경우에도 DB에 쓰기가 실행되는 경우 백업버전에 따라 서로 다른 데이터를 갖고 있을 수 있다.(비일관성의 영속성)

###### 분석 질의와 무결성 확인
데이터 무결성검증( 오염확인또는 주기적인 모니터링 )은 data freeze가 필요하다. 그렇지 않을 경우 결과가 이상할 수 잇다.

이를 위해 "스냅숏격리"를 사용한다.
각 트랜잭션은 일관된 스냅숏으로 부터 읽는다. 커밋된 상태였던 모든데이터를 보는데 트랜잭션에 의해 나중에 데이터가 바뀌더라도 각 트랜잭션은 특정한 과거시점의 데이터를 볼뿐이다.

##### 스냅숏 격리의 구현
스냅숏 격리 구현은 더티쓰기를 방지하기 위해 쓰기 잠금을 사용하지만,
스냅숏 격리의 핵심원리는 읽는 쪽에서든 쓰는 쪽에서는 서로 차단하지 않는다는 것이다.
<img width="499" alt="image" src="https://user-images.githubusercontent.com/5934737/195359377-04c0b4a5-afdb-4bae-baf8-9bf1814cb044.png">

방법 : MVCC 다중버전 동시성 제어
- 데이터 베이스가 여러가지의 버전을 유지한다.
- 데이터 베이스가 읽기 격리만 제공이 필요하다면 커밋된 버전과 커밋되지 않은 버전만 제공하면된다.
- 커밋 후 읽기는 독립된 스냅샷을 제공하고 스냅숏격리는 전체 트랜잭션에 대해 동일한 스냅숏을 사용한다.
- 테이블의 각로우에는 로우를 삽입한 트랜잭션의 id를 갖는 created_by 필드가 있다.
- delete_by 필드는 지워졋다고 표시(use_yn개념)하는 필드를 유지한다.
- garbage collection을 아무 트랜잭션도 더이상 삭제된 데이터에 접근하지 않는다면, 삭제한다.

##### 일관딘 스냅숏을 보는 가시성 규칙

동작방식
1. DB는 각 트랜잭션을 시작시 그시점에 진행중인(아직 커밋이나 어보트되지않은) 모든 트랜잭션목록을 만든다. 이트랜잭션들이 쓴데이터는 모두 무시된다.
2. 어보트된 트랜잭션이 쓴데이터는 모두 무시된다.
3. 트랜잭션 ID가 더 큰 (현재 트랜잭션이 시작된 이후)트랜잭션이 쓴데이터는 그 트랜잭션의 커밋여부와 상관없이 모두 무시된다.
4. 그 밖의 모든 데이터는 애플리케이션의질의로 볼수 있다.

이 규칙은 객체 생성과 삭제 모두에 적요되는데, 트랜잭션 12가 계좌 2를 읽으면 잔고가 500이 잇는 것을 보개되고 500달러잔고 삭제는 tx13이 실행했고( 규칙 3에 따라 tx12는 tx13의 삭제를 볼 수 없다.) 400 달러 잔고 생성은 볼 수가 없다.

바꿔 말하면 아래 조건이 모두 참이 면 객체를 볼 수 있다.





