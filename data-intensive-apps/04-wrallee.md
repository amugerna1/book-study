# 4장. 부호화와 발전(Encoding and Evolution)

프로그램은 보통 두 가지 이상의 형태로 표현된 데이터를 사용해 동작한다.  
객체, 배열, 해시테이블 등의 구조는 CPU에서 효율적으로 접근하고 조작할 수 있지만, 네트워크를 통해 전송하기에는 적합하지 않다.  
따라서 이를 바이트로 전환하는 부호화(**=직렬화**)를 하게되는데, 이 때 다양한 이진 부호화 기술들이 활용된다.

이번 장에서는 서비스 간 데이터를 교환하는 여러가지 방식과 그 세부 구현들(특히 이진 부호화)에 대해 알아보자.

![image-20220915032549490](04-wrallee.assets/image-20220915032549490.png)

위 그림에서 서비스 측면에서는 크게 **데이터베이스, 웹서비스/RPC, 메시징서비스** 정도로 나눌 수 있고  
부호화 방식은 크게 **텍스트, 이진부호화**로 나뉘며, 각 방식에 따른 기술들을 소개하고 있다.

<br/>

## 전달방식 1 - 텍스트

가장 익숙한 텍스트 전달방식으로 대표적으로 JSON, XML, CSV가 있으며, 웹서비스(REST, SOAP)에서 사용된다.  
텍스트 형식은 사용이 쉽고 사람이 읽을 수 있는 형태이며 특히 JSON의 경우 웹 브라우저 자체에서 지원하는 형식이기 때문에 가장 널리 사용된다.

하지만 이러한 편리함에도 불구하고 몇 가지 단점이 존재한다.

- 수(number)의 표현이 애매하다.
- 큰 수를 다룰 때 문제가 발생할 수 있다.
- 이진문자열을 지원하지 않는다(ex. 매핑되는 문자가 없는 바이트열).
- XML, JSON은 스키마를 지원하지만 적용하기가 현실적으로 어렵다.
- CSV의 경우 스키마가 따로 없어서 컬럼 추가 시 잘못 해석될 가능성이 있다.

이러한 단점에도 불구하고 다양한 용도와 편의성때문에 지금까지 많이 사용됐고, 앞으로도 많이 사용될것이다.

<br/>

## 전달방식 2 - 이진 부호화

많은 프로그래밍 언어는 인메모리 객체를 부호화하는 라이브러리를 갖고있다.  
내장 라이브러리는 간편하지만 많은 문제점을 야기하기 때문에 일시적인 목적 외에는 사용이 지양된다.

- 부호화가 특정 언어에 종속되면 다른 시스템이 데이터를 읽거나 쓰기 어렵다.
- 복호화 시 클래스를 인스턴스화 하기 때문에 원격 코드 실행(RCE) 취약점에 노출될 수 있다.
- 상위/하위호환성 문제가 발생할 수 있다.
- 성능 문제가 발생할 수 있다.

이진 부호화는 데이터베이스, RPC, 메시징서비스에서 사용되는 방식으로, 작은 데이터셋의 경우 부호화 형식 선택으로 얻는 이득이 적지만, 테라바이트 정도가 되면 데이터 타입의 선택이 큰 영향을 미친다. XML, JSON을 이진 부호화 하는 방식(MessagePack, WBXML 등)도 생겨났지만 장점이 크지 않아 널리 채택되진 않았다.

이번 장에서는 아래 레코드를 각 부호화 기술에 따라 변형해가며 설명을 돕는다. 눈에 잘 익혀두자.

**[예제 레코드]**

```json
{
    "userName": "Martin",
    "favoriteNumber": 1337,
    "interests": ["daydreaming", "hacking"]
}
```

<br/>

### 1) MessagePack

MessagePack은 JSON을 이진부호로 바꾸는 라이브러리다.

#### MessagePack의 바이트 시퀀스

> Spec: https://github.com/msgpack/msgpack/blob/master/spec.md#formats

아래 이미지는 Formats 표에 따라 각 바이트를 해석할 수 있다.  
기존의 JSON 문자열(81바이트)을 바이트 시퀀스로 변환했음에도 길이는 **크게 줄어들지 않았다**.  
이처럼 가독성을 해치는데 반해 크게 이득이 크지 않다는 점 때문에 인기를 끌지 못했다.

![image-20220915025754117](04-wrallee.assets/image-20220915025754117.png)

<br/>

### 2) 스리프트와 프로토콜 버퍼

스리프트(페이스북 개발), 프로토콜 버퍼(구글 개발)는 모두 데이터를 이진부호로 바꾸는 라이브러리다.

두 라이브러리 모두 부호화할 데이터를 위한 스키마가 필요하며, 이러한 스키마를 기술하는 언어를 IDL(Interface Definition Language)이라고 한다. 예제 레코드를 스리프트, 프로토콜 버퍼의 IDL로 각각 기술하면 아래와 같다.

**[스리프트 IDL]**

```idl
struct Person {
  1: required string       userName,
  2: optional i64          favoriteNumber,
  3: optional list<string> interests
}
```

**[프로토콜 버퍼 IDL]**

```idl
message Person {
    required string user_name       = 1;
    optional int64  favorite_number = 2;
    repeated string interests       = 3;
}
```

두 라이브러리는 이러한 IDL로부터 다양한 언어로 코드를 생성하는 도구를 제공하며, 프로그램은 이렇게 생성된 코드를 통해 레코드를 부호화(encoding), 복호화(decoding) 할 수 있다. 또한 required, optional 등의 표기를 통해 런타임 오류를 잡아낼 수 있다는 장점도 있다.

<br/>

#### 스리프트의 바이트 시퀀스(컴팩트 프로토콜)

> Spec: https://github.com/apache/thrift/blob/master/doc/specs/thrift-compact-protocol.md#struct-encoding

스리프트에는 크게 바이너리프로토콜, 컴팩트프로토콜이 있는데 컴팩트 프로토콜에 대해 알아보자.

스리프트와 프로토콜 버퍼에서는 필드이름 대신 **필드태그(1, 2, 3, ...)**를 활용하기 때문에 필드이름이 없이도 어떤 필드를 다루는지 알수 있다.  
이 방식을 사용함과 동시에, 수 타입 부호화 시 [가변 길이 정수](https://lucene.apache.org/core/3_5_0/fileformats.html#VInt)를 사용함으로써 바이트 시퀀스의 길이를 줄였다.  
그 결과 아래 예제에서 34바이트로 줄었음을 확인할 수 있다. 프로토콜 버퍼의 부호화 방식도 이와 유사하다.

![image-20220915025821734](04-wrallee.assets/image-20220915025821734.png)

#### 스키마 발전

여기서의 "스키마 발전"이란 시간이 지남에 따라 스키마가 변화하는것을 말한다.  
흔히 컬럼이 추가되는 등의 일이 있다. 이런 상황에서 중요시 되는것이 바로 **상위/하위호환성**이다.

- 상위호환성: 예전 코드는 새로운 코드가 기록한 데이터를 읽을 수 있어야 한다.
- 하위호환성: 새로운 코드는 예전 코드가 기록한 데이터를 읽을 수 있어야 한다.

이러한 스키마 발전은 긴 시간동안도 일어나고 짧은 시간동안에도 일어날 수 있다.  
예를 들어 애플리케이션을 롤링 업데이트 할 경우 실제로 구버전/신버전이 공존하게 되며, 호환성이 지켜지지 않았을 때 문제가 발생한다.

<br/>

```idl
struct Person {
  1: required string       userName,
  2: optional i64          favoriteNumber,
  3: optional list<string> interests
}
```

**필드 태그와 스키마 발전**

필드 태그는 변경할 수 없다(필드 이름은 변경 가능). 만약 새로운 필드를 추가한다면 해당 필드에는 새로운 태그 번호를 부여한다.  
새로운 태그번호에 대해 예전 코드는 해당 번호를 무시하고, 기존 태그번호는 항상 같은 의미를 가지기 때문에 상위/하위 호환성이 유지된다.  
`required`, `optional` 역시 신경써야 하는데, 스키마 초기 배포 이후에 추가되는 필드는 `optional`이거나 기본값을 가져야 상위 호환성이 유지된다.  
반대로 필드를 삭제할 경우 `required` 필드는 삭제할 수 없다.

**데이터타입과 스키마 발전**

데이터타입의 경우에도 변경할 수 없다. 예를 들어 32비트 정수를 64비트의 정수로 바꾼다면 새로운 코드가 기록한 데이터를 예전 코드가 읽을 때 데이터가 잘리므로 상위호환성이 지켜지지 않는다.

<br/>

### 3) 아브로

아브로는 앞선 사례들과 다르지만 대적할만한 이진부호화 형식이다.  
아브로는 스리프트가 하둡의 사용 사례에 적합하지 않아 하둡의 하위 프로젝트로 시작되었다.

아브로에는 두 개의 스키마 언어가 있다. 하나는 사람이 읽을 수 있는 IDL, 하나는 기계가 이해할 수 있는 JSON 언어다.

**[IDL 표현]**

```idl
record Person {
    string               userName;
    union { null, long } favoriteNumber = null;
    array<string>        interests;
}
```

**[JSON 표현]**

```json
{
    "type": "record",
    "name": "Person",
    "fields": [
        {"name": "userName",       "type": "string"},
        {"name": "favoriteNumber", "type": ["null", "long"], "default": null},
        {"name": "interests",      "type": {"type": "array", "items": "string"}}
    ]
}
```

앞선 방식과 달리 아브로 스키마에는 태그번호가 없다. 이 스키마를 활용한 결과값은 지금까지 중 가장 짧은 32바이트다.

<br/>

#### 아브로의 바이트 시퀀스

> Spec: https://avro.apache.org/docs/1.11.1/specification/#data-serialization-and-deserialization

아브로에서 바이트열에는 앞선 방식과 다르게 필드, 데이터타입 식별정보가 없다. 부호화는 단순히 연결된 값으로 구성되기 때문에 스키마에 나타난 순서대로 필드를 살펴보고, 각 필드의 데이터타입을 파악해야 한다. 이것은 데이터를 쓰고 읽는 **스키마가 정확하게 같아야** 올바르게 복호화 된다는 것을 의미하지만 실제는 그렇지 않아도 된다. 이 내용은 아래 쓰기/읽기 스키마 설명을 통해 이해할 수 있다.

![image-20220915041103928](04-wrallee.assets/image-20220915041103928.png)

<br/>

#### 아브로의 스키마 발전

그렇다면 아브로는 스키마가 변경될경우 호환성이 망가지는것일까? 아브로의 스키마 발전 규칙에 대해 알아보자.  
아브로는 쓰기/읽기 스키마는 동일하지 않아도 되며, 호환 가능하면 된다는 생각을 기반으로 이를 해결했다.

> 쓰기/읽기 스키마는 따로 관리되는것은 아니고, 단순히 부호화/복호화에 직접 사용될 스키마를 말한다.

<br/>

데이터를 복호화 할 때 아브로 라이브러리는 쓰기/읽기 스키마를 살펴보고 그 차이를 해소한다.  
예를 들어 아래와 같이 읽기/쓰기 스키마가 다를 때 아브로는 다음 절차에 따라 **쓰기 스키마에서 읽기 스키마로 데이터를 변환**한다.

- 쓰기 스키마와 읽기 스키마 간 필드 순서 차이는 스키마 해석 시 이름으로 필드를 일치시켜 해소한다.
- 읽기 스키마에는 없고, 쓰기 스키마에만 존재하는 필드는 무시한다.
- 읽기 스키마에만 있고, 쓰기 스키마에는 없는 필드는 읽기 스키마에 선언된 기본값으로 채운다.

![image-20220915053720021](04-wrallee.assets/image-20220915053720021.png)

**스키마 발전 규칙**

따라서 아브로에서의 상위/하위 호환성은 쓰기/읽기 스키마가 아래 조합인 경우라고 이해하면 된다.

- 상위 호환성: 새로운 쓰기 스키마 + 예전 읽기 스키마
- 하위 호환성: 예전 쓰기 스키마 + 새로운 읽기 스키마

호환성을 유지하기 위해서는 기본값이 있는 필드만 추가/삭제할 수 있다. 그렇지 않을 경우 읽기/쓰기 스키마 차이를 해소하는 세번째 절차가 문제가 된다.

<br/>

> *읽기 스키마에만 있고, 쓰기 스키마에는 없는 필드는 읽기 스키마에 선언된 기본값으로 채운다.*

만약 위 이미지의 Reader 스키마에 기본값이 없는 userID를 추가했다고 하면, 예전에 쓰여진 레코드를 읽을 수 없어서 하위 호환성이 깨진다.  
만약 위 이미지의 Writer 스키마에서 기본값이 없는 userName 필드를 삭제했다고 하면, 예전 읽기 스키마로 읽을 수 없어서 상위 호환성이 깨진다.

아브로는 타입을 변환할 수 있으므로 필드의 데이터타입 변경이 가능하다. 또한 필드 이름도 변경 가능한데, 읽기 스키마는 필드 이름에 별칭을 포함할 수 있어 예전 쓰기 스키마와 필드 이름을 매치할 수 있다. 즉 필드 이름 변경은 하위 호환성이 있지만 상위 호환성은 없다.

<br/>

#### 쓰기 스키마는 어떻게 아는걸까?

특정 레코드가 어떤 스키마로 부호화 되었는지 어떻게 확인할지에 대한 의문도 있을것이다.  
당연하지만 레코드에 스키마 전체를 담아보내는것은 아니다. 몇 가지 예를 소개하면 아래와 같다.

- **많은 레코드가 있는 대용량 파일**: 모두 동일한 스키마로 부호화 된 파일을 만들고 시작부분에 한번만 쓰기 스키마를 포함시키는 방법.
- **개별적으로 기록된 레코드를 가진 데이터베이스**: 레코드 시작부분에 버전 번호를 포함하고 별도의 데이터베이스에서 가져오는방법.
- **네트워크 연결을 통해 레코드 보내기**: 사용할 스키마 버전을 합의해서 해당 버전으로만 레코드 전달하는 방법.



요약하면 서비스간 데이터를 교환하는 여러가지 방식에 대해 소개하는것이 이 장의 핵심이다.

부호화(인코딩/디코딩)

상/하위 호환성, 스키마발전(스키마변경)

동적 생성 스키마

객체컨테이너



프로토콜 버퍼

스리프트

아브로



이진부호화의 장점?속성?

- 필드 이름 생략 가능? 이진 JSON 변형보다 절약
- 스키마가 최신인지 확신 가능(강제화)
- 스키마 데이터베이스를 관리한다면 상위/하위 호환성 체크 가능
- 컴파일 시점에 타입체크 가능

요약하면 스키마 발전은 스키마리스 또는 읽기스키마 JSON 데이터베이스가 제공하는것과 동일한 종류의 유연성을 제공하며 데이터나 도구 지원도 더 잘 보장한다.



데이터플로 모드

- 데이터베이스를 통한 데이터플로
  - MySql은 필요하지 않은 상황에서도 전체 테이블을 다시 기록함?
- 서비스 호출을 통해(REST, RPC)
  - 웹서비스(REST, SOAP)
  - RPC - IDL을 통해 스키마를 공유
    - RPC는 원격 서비스를 로컬 객체처럼 보이게 하는거 자체가 문제인데 의미가 없진않다
- 비동기 메시지 전달을 통해
  - 메시지 브로커는 바이트열을 저장하므로 모든 부호화 형식을 사용할 수 있다.
  - 분산액터프레임워크
    - 메세지브로커와 액터프로그래밍모델?



SOAP도 wsdl을 통해 Stub을 생성할수 있는데 RPC와 무슨차이? http에 종속되지 않는다는점? 부호화의 종류를 선택가능하단점?