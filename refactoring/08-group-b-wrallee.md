## 냄새 8. 산탄총 수술(Shotgun Sergery)

한 변경사항이 생겼을 때 여러 모듈(함수 or 클래스)을 수정해야 하는 상황. 응집도는 높아야 되고 결합도는 낮아야 된다. 응집도가 낮아졌을 때 주로 이런 문제가 발생한다. 앞의 "냄새 7. 뒤엉킨 변경"과 반대 상황이다. **변경 사항이 여러곳에 흩어진다면 찾아서 고치기도 어렵고 중요한 변경 사항을 놓칠 수 있는 가능성도 생긴다.** 

관련 리팩토링 기술들

- 함수 옮기기(8.1), [필드 옮기기(8.2)](#리팩토링 27. 필드 옮기기(8.2))

- 여러 함수를 클래스로 묶기(6.9)

- 단계 쪼개기(6.11)

- [함수 인라인(6.2)](#리팩토링 28. 함수 인라인(6.2)), [클래스 인라인(7.6)](#리팩토링 29. 클래스 인라인(7.6)) 

<br/>

### 리팩토링 27. 필드 옮기기(8.2)

처음에 타당해 보였던 구조도 도메인과 데이터 구조에 대해 더 익혀나감에 따라 잘못된 구조가 되는 경우도 있다. <ins>생성자를 먼저 바꿔서 IDE의 도움을 받아도 좋다.</ins>

#### 단서

1. 어떤 데이터를 항상 어떤 레코드와 함께 전달하는 경우.
2. 어떤 레코드를 변경할 때 다른 레코드에 있는 필드를 함께 변경해야 하는 경우.
3. 여러 레코드에 동일한 필드를 수정해야 하는 경우.

#### 절차

1. 소스 필드가 캡슐화 되어 있지 않다면 캡슐화한다.
2. 테스트한다.
3. 타깃 객체에 필드(와 접근자 메서드들)를 생성한다.
4. 정적 검사를 수행한다.
5. 소스 객체에서 타깃 객체를 참조할 수 있는지 확인한다.
6. 접근자들이 타깃 필드를 사용하도록 수정한다.
7. 테스트한다.
8. 소스 필드를 제거한다.
9. 테스트한다.

#### 예제



<br/>

### 리팩토링 28. 함수 인라인(6.2)

함수 추출하기의 반대에 해당하는 리팩토링이다. 과도하게 나눠진 함수들을 다시 조립해서 간소화하자. <ins>Ctrl+Alt+N으로 IDE의 도움을 받을 수 있다.</ins>

#### 단서

1. 함수의 내용이 이름만큼 직관적으로 표현되는 경우
2. 함수 리팩토링이 잘못되었다고 판단될 경우 함수 추출하기를 위해 함수를 인라인한다.
3. 단순히 메소드를 감싸는 우회형 메소드일 경우
4. 상속구조에서 오버라이딩 하고 있는 메소드는 인라인 할 수 없다.

#### 절차

1. 다형 메서드인지 확인한다(서브클래스에서 오버라이드 하는 메서드는 인라인하면 안된다).
2. 인라인할 함수를 호출하는 곳을 모두 찾는다.
3. 각 호출문을 함수 본문으로 교체한다.
4. 하나씩 교체할때마다 테스트한다.
5. 함수 정의(원래 함수)를 삭제한다.

#### 예제



<br/>

### 리팩토링 29. 클래스 인라인(7.6)

"클래스 추출하기"의 반대에 해당하는 리팩토링. 특정 클래스에 남은 역할이 거의 없을 때 클래스를 인라인 할 수 있다. <ins>필드를 먼저 옮겨서 컴파일 에러를 유발하면서 시작하면 좋다.</ins>

#### 단서

1. 리팩토링을 진행하다 보면 클래스의 존재 이유가 빈약해지는 경우가 발생할 수 있다.
1. 함수 인라인과 마찬가지로 클래스의 역할을 모으고 이후 클래스 추출하기를 적용하는데에도 사용된다.

#### 방법

- 소스 클래스의 각 public 메서드에 대응하는 메서드들을 타깃 클래스에 생성한다. 이 메서드들은 단순히 작업을 소스 클래스로 위임해야 한다.
- 소스 클래스의 메서드를 사용하는 코드를 모두 타깃 클래스의 위임 메서드를 사용하도록 바꾼다. 하나씩 바꿀 때마다 테스트한다.
- 소스 클래스의 메서드와 필드를 모두 타깃 클래스로 옮긴다. 하나씩 옮길 때마다 테스트 한다.
- 소스 클래스를 삭제하고 조의를 표한다.

#### 예제


