# 익명 클래스보다는 람다를 사용하라
> 함수형 인터페이스(`functional interface`) : 추상 메서드를 하나만 담은 인터페이스<br>
> 함수 객체(`function object`) : 함수형 인터페이스의 인스턴스
<br>

### 자바에서 함수를 표현할 때 사용하는 기법 history
* `~ JDK 1.1` : 추상 메서드를 하나만 담은 인터페이스의 인스턴스를 사용
* `JDK 1.1 ~` : 익명 클래스로 함수 객체를 만들어서 사용
  ```java
    Collections.sort(words, new Comparator<String>() {
      public int compare(String s1, String s2) {
        return Integer.compare(s1.length(), s2.length());
      }
    });
  ```
* `JDK 8 ~` : 추상 메서드 하나짜리 인터페이스의 인스턴스를 **람다식을 사용해** 만들어서 사용
  ```java
  Collections.sort(words, (s1,s2) -> Integer.compare(s1.length(), s2.length()));
  ```
<br>

### 람다의 특징
* 람다는 컴파일러가 타입을 추론해 준다.
  * `JDK 8 ~` 에 작성한 코드에 반환값의 타입을 명시하지 않은 이유이다.
  * 타입을 명시해야 코드가 더 명확할 때만 제외하고는, 람다의 모든 매개변수 타입은 생략하자.
<br>

### 람다 사용 시 유의사항
1. 람다는 이름도 없고 문서화도 못 한다.
    * 따라서 코드 자체로 동작이 명확히 설명되지 않거나, 코드 줄 수가 많아지면 람다를 쓰지 말아야 한다.
2. 람다는 짧게 끝낼수록 좋다.
    * 세 줄을 넘어가면 가독성이 심히 나빠지니 줄이거나, 람다를 사용하지 않는 방향으로 리팩터링 하는 게 낫다.
3. 간혹 익명 클래스를 람다로 대체할 수 없는 경우도 있다.
    * 람다는 함수형 인터페이스에서만 쓰인다.
    * 그러므로, "추상 클래스의 인스턴스를 만들 때" 와 "추상 메서드가 여러 개인 인터페이스의 인스턴스를 만들 때" 는 익명 클래스를 써야 한다.
4. 람다는 자신을 참조할 수 없다.
    * 람다는 함수 정의 형태를 띠고 있지만, 런타임 시에 인터페이스의 익명 구현 객체로 생성된다.
    * 따라서 람다에서의 `this` 는 바깥 인스턴스(람다식을 실행한 객체의 참조)이다.
    * 함수 객체가 자신을 참조해야 한다면, 이 경우에도 익명 클래스를 써야 한다.
<br>

### 정리
* 자바8 이 등장하면서 작은 함수 객체를 구현하는 데 적합한 람다가 도입되었다.
* 익명 클래스는 (함수형 인터페이스가 아닌) 타입의 인스턴스를 만들 때만 사용하라.
